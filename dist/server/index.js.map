{"version":3,"sources":["../../src/server/client/request.ts","../../src/server/client/endpoints.ts","../../src/server/client/createClient.ts","../../src/server/client/pagination.ts","../../src/server/client/attachments.ts","../../src/server/repos/createTableRepo.ts","../../src/server/repos/leadsRepo.ts"],"sourcesContent":["/**\n * @name AirtableRequestConfig\n * @kind Type\n * @summary Configuration object for Airtable HTTP requests containing authentication token and timeout settings.\n *\n * @description\n * Type definition for request configuration used by airtableRequest function.\n * Contains authentication token for Authorization header and timeout value for request cancellation.\n * Used internally by client methods to configure HTTP requests to Airtable API.\n * Token is included in Bearer authentication header for all requests.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Valid Airtable API token\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - used for HTTP requests\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - type definition only\n * @latency Not applicable\n * @memory Not applicable\n * @rateLimit Not applicable\n * @notes Not applicable\n *\n * @security\n * @inputSanitization Not specified\n * @secretsHandling Token should be kept secret and never logged. Used in Authorization header.\n * @pii Not applicable\n *\n * @compatibility\n * @supported All TypeScript/JavaScript environments\n * @notSupported None\n *\n * @param {string} token - Airtable API personal access token or OAuth token. Required for authentication.\n * @param {number} timeoutMs - Request timeout in milliseconds. Request will be aborted if not completed within this time.\n *\n * @returns {Object} Object with required token and timeoutMs properties.\n *\n * @example\n * // Basic usage\n * const config: AirtableRequestConfig = {\n *   token: \"pat123...\",\n *   timeoutMs: 15000\n * };\n *\n * @remarks\n * Token is included in Authorization header as \"Bearer {token}\". Timeout uses AbortController for cancellation.\n *\n * @see airtableRequest\n */\nexport type AirtableRequestConfig = {\n  token: string;\n  timeoutMs: number;\n};\n\n/**\n * @name AirtableHttpError\n * @kind Class\n * @summary Base error class for Airtable API HTTP errors with status code, response details, and normalized error messages.\n *\n * @description\n * Error class extending native Error for representing HTTP errors from Airtable API requests.\n * Includes HTTP status code, status text, request URL, and optional response details.\n * Error message is normalized from Airtable error response format when available.\n * Thrown by airtableRequest when API returns non-2xx status codes or when requests timeout.\n * Provides structured error information for error handling and debugging.\n * Base class for specific error types (AirtableAuthError, AirtableNotFoundError, etc.).\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not specified\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - simple error object creation\n * @latency Not applicable\n * @memory O(1) - stores error metadata\n * @rateLimit Not applicable\n * @notes Lightweight error class.\n *\n * @security\n * @inputSanitization Error messages are normalized from API responses. Details may contain API error structure.\n * @secretsHandling Details may contain API response data. Avoid logging full details in production.\n * @pii Details may contain PII if API error responses include record data\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {Object} args - Arguments object for constructing the error.\n * @param {number} args.status - HTTP status code from the API response (e.g., 400, 404, 500).\n * @param {string} args.statusText - HTTP status text from the response (e.g., \"Bad Request\", \"Not Found\").\n * @param {string} args.url - The URL that was requested when the error occurred.\n * @param {string} args.message - Normalized error message. May include Airtable error type and message if available.\n * @param {unknown} [args.details] - Optional parsed response body containing additional error details from Airtable API.\n *\n * @returns {AirtableHttpError} Error instance with status, statusText, url, message, and optional details properties.\n *\n * @example\n * // Basic usage (thrown by airtableRequest)\n * try {\n *   await airtableRequest({ url, method: \"GET\", config });\n * } catch (err) {\n *   if (err instanceof AirtableHttpError) {\n *     console.error(`API error ${err.status}: ${err.message}`);\n *     console.error(`URL: ${err.url}`);\n *   }\n * }\n *\n * @example\n * // Manual construction\n * throw new AirtableHttpError({\n *   status: 404,\n *   statusText: \"Not Found\",\n *   url: \"https://api.airtable.com/v0/app123/Tasks/rec456\",\n *   message: \"NOT_FOUND: Record not found\",\n *   details: { error: { type: \"NOT_FOUND\", message: \"Record not found\" } }\n * });\n *\n * @remarks\n * Error messages are normalized from Airtable API error format: \"{type}: {message}\" when available, otherwise \"{status} {statusText}\".\n * Status 408 is used for timeout errors. Details property contains the parsed API response body when available.\n * This is the base class; specific error types extend this for better error handling (e.g., AirtableAuthError, AirtableNotFoundError).\n *\n * @see airtableRequest\n * @see AirtableAuthError\n * @see AirtableNotFoundError\n * @see AirtableValidationError\n * @see AirtableRateLimitError\n * @see AirtableNetworkError\n */\nexport class AirtableHttpError extends Error {\n  readonly status: number;\n  readonly statusText: string;\n  readonly url: string;\n  readonly details?: unknown;\n\n  constructor(args: { status: number; statusText: string; url: string; message: string; details?: unknown }) {\n    super(args.message);\n    this.name = \"AirtableHttpError\";\n    this.status = args.status;\n    this.statusText = args.statusText;\n    this.url = args.url;\n    this.details = args.details;\n  }\n}\n\n/**\n * @name AirtableAuthError\n * @kind Class\n * @summary Specific error class for Airtable API authentication and authorization errors (401, 403).\n *\n * @description\n * Error class extending AirtableHttpError for representing authentication and authorization failures.\n * Thrown when API returns 401 (Unauthorized) or 403 (Forbidden) status codes.\n * Provides better developer experience by allowing specific error type checking.\n * Created automatically by toSpecificError function when status is 401 or 403.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not specified\n *\n * @dependencies\n * @requires AirtableHttpError Base error class\n *\n * @performance\n * @complexity O(1) - simple error object creation\n * @latency Not applicable\n * @memory O(1) - stores error metadata\n * @rateLimit Not applicable\n * @notes Lightweight error class.\n *\n * @security\n * @inputSanitization Error messages are normalized from API responses\n * @secretsHandling Details may contain API response data. Avoid logging full details in production.\n * @pii Details may contain PII if API error responses include record data\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {AirtableHttpError} base - Base AirtableHttpError instance to wrap. Must have status 401 or 403.\n *\n * @returns {AirtableAuthError} Error instance with status 401 or 403, inheriting all properties from base error.\n *\n * @example\n * // Basic usage (thrown by airtableRequest)\n * try {\n *   await airtableRequest({ url, method: \"GET\", config });\n * } catch (err) {\n *   if (err instanceof AirtableAuthError) {\n *     console.error(\"Authentication failed. Check your token.\");\n *   }\n * }\n *\n * @remarks\n * This error type is provided for better developer experience (DX). Allows specific error handling for auth failures.\n * Created automatically by toSpecificError when status is 401 or 403.\n *\n * @see AirtableHttpError\n * @see toSpecificError\n */\nexport class AirtableAuthError extends AirtableHttpError {\n  constructor(base: AirtableHttpError) {\n    super({ status: base.status, statusText: base.statusText, url: base.url, message: base.message, details: base.details });\n    this.name = \"AirtableAuthError\";\n  }\n}\n\n/**\n * @name AirtableRateLimitError\n * @kind Class\n * @summary Specific error class for Airtable API rate limit errors (429).\n *\n * @description\n * Error class extending AirtableHttpError for representing rate limit violations.\n * Thrown when API returns 429 (Too Many Requests) status code.\n * Provides better developer experience by allowing specific error type checking.\n * Created automatically by toSpecificError function when status is 429.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not specified\n *\n * @dependencies\n * @requires AirtableHttpError Base error class\n *\n * @performance\n * @complexity O(1) - simple error object creation\n * @latency Not applicable\n * @memory O(1) - stores error metadata\n * @rateLimit Not applicable\n * @notes Lightweight error class.\n *\n * @security\n * @inputSanitization Error messages are normalized from API responses\n * @secretsHandling Details may contain API response data. Avoid logging full details in production.\n * @pii Details may contain PII if API error responses include record data\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {AirtableHttpError} base - Base AirtableHttpError instance to wrap. Must have status 429.\n *\n * @returns {AirtableRateLimitError} Error instance with status 429, inheriting all properties from base error.\n *\n * @example\n * // Basic usage (thrown by airtableRequest)\n * try {\n *   await airtableRequest({ url, method: \"GET\", config });\n * } catch (err) {\n *   if (err instanceof AirtableRateLimitError) {\n *     console.error(\"Rate limit exceeded. Implement backoff strategy.\");\n *   }\n * }\n *\n * @remarks\n * This error type is provided for better developer experience (DX). Allows specific error handling for rate limits.\n * Created automatically by toSpecificError when status is 429.\n *\n * @see AirtableHttpError\n * @see toSpecificError\n */\nexport class AirtableRateLimitError extends AirtableHttpError {\n  constructor(base: AirtableHttpError) {\n    super({ status: base.status, statusText: base.statusText, url: base.url, message: base.message, details: base.details });\n    this.name = \"AirtableRateLimitError\";\n  }\n}\n\n/**\n * @name AirtableNotFoundError\n * @kind Class\n * @summary Specific error class for Airtable API not found errors (404).\n *\n * @description\n * Error class extending AirtableHttpError for representing resource not found errors.\n * Thrown when API returns 404 (Not Found) status code.\n * Provides better developer experience by allowing specific error type checking.\n * Created automatically by toSpecificError function when status is 404.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not specified\n *\n * @dependencies\n * @requires AirtableHttpError Base error class\n *\n * @performance\n * @complexity O(1) - simple error object creation\n * @latency Not applicable\n * @memory O(1) - stores error metadata\n * @rateLimit Not applicable\n * @notes Lightweight error class.\n *\n * @security\n * @inputSanitization Error messages are normalized from API responses\n * @secretsHandling Details may contain API response data. Avoid logging full details in production.\n * @pii Details may contain PII if API error responses include record data\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {AirtableHttpError} base - Base AirtableHttpError instance to wrap. Must have status 404.\n *\n * @returns {AirtableNotFoundError} Error instance with status 404, inheriting all properties from base error.\n *\n * @example\n * // Basic usage (thrown by airtableRequest)\n * try {\n *   await airtableRequest({ url, method: \"GET\", config });\n * } catch (err) {\n *   if (err instanceof AirtableNotFoundError) {\n *     console.error(\"Resource not found. Check table name or record ID.\");\n *   }\n * }\n *\n * @remarks\n * This error type is provided for better developer experience (DX). Allows specific error handling for not found errors.\n * Created automatically by toSpecificError when status is 404.\n *\n * @see AirtableHttpError\n * @see toSpecificError\n */\nexport class AirtableNotFoundError extends AirtableHttpError {\n  constructor(base: AirtableHttpError) {\n    super({ status: base.status, statusText: base.statusText, url: base.url, message: base.message, details: base.details });\n    this.name = \"AirtableNotFoundError\";\n  }\n}\n\n/**\n * @name AirtableValidationError\n * @kind Class\n * @summary Specific error class for Airtable API validation errors (422).\n *\n * @description\n * Error class extending AirtableHttpError for representing validation failures.\n * Thrown when API returns 422 (Unprocessable Entity) status code.\n * Typically indicates invalid field values or missing required fields.\n * Provides better developer experience by allowing specific error type checking.\n * Created automatically by toSpecificError function when status is 422.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not specified\n *\n * @dependencies\n * @requires AirtableHttpError Base error class\n *\n * @performance\n * @complexity O(1) - simple error object creation\n * @latency Not applicable\n * @memory O(1) - stores error metadata\n * @rateLimit Not applicable\n * @notes Lightweight error class.\n *\n * @security\n * @inputSanitization Error messages are normalized from API responses\n * @secretsHandling Details may contain API response data. Avoid logging full details in production.\n * @pii Details may contain PII if API error responses include record data\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {AirtableHttpError} base - Base AirtableHttpError instance to wrap. Must have status 422.\n *\n * @returns {AirtableValidationError} Error instance with status 422, inheriting all properties from base error.\n *\n * @example\n * // Basic usage (thrown by airtableRequest)\n * try {\n *   await airtableRequest({ url, method: \"POST\", config, body: { fields: {} } });\n * } catch (err) {\n *   if (err instanceof AirtableValidationError) {\n *     console.error(\"Validation failed. Check field values:\", err.details);\n *   }\n * }\n *\n * @remarks\n * This error type is provided for better developer experience (DX). Allows specific error handling for validation failures.\n * Created automatically by toSpecificError when status is 422.\n *\n * @see AirtableHttpError\n * @see toSpecificError\n */\nexport class AirtableValidationError extends AirtableHttpError {\n  constructor(base: AirtableHttpError) {\n    super({ status: base.status, statusText: base.statusText, url: base.url, message: base.message, details: base.details });\n    this.name = \"AirtableValidationError\";\n  }\n}\n\n/**\n * @name AirtableNetworkError\n * @kind Class\n * @summary Specific error class for network/transport failures (DNS, connection reset, etc.) during Airtable API requests.\n *\n * @description\n * Error class extending AirtableHttpError for representing network-level failures.\n * Thrown when fetch API encounters network errors (DNS failures, connection resets, timeouts, etc.).\n * Uses synthetic status code 503 (Service Unavailable) to normalize network errors with HTTP errors.\n * Provides better developer experience (DX) with specific error type for easier error handling and retry logic.\n * Created when fetch throws TypeError or other network-related exceptions.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - represents network failures\n *\n * @dependencies\n * @requires AirtableHttpError Base error class\n *\n * @performance\n * @complexity O(1) - simple error object creation\n * @latency Not applicable\n * @memory O(1) - stores error metadata\n * @rateLimit Not applicable\n * @notes Lightweight error class.\n *\n * @security\n * @inputSanitization Error messages are extracted from network error objects\n * @secretsHandling Details may contain network error information. Avoid logging full details in production.\n * @pii Not applicable\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {Object} args - Arguments object for constructing the error.\n * @param {string} args.url - The URL that was requested when the network error occurred.\n * @param {string} args.message - Error message describing the network failure.\n * @param {unknown} [args.details] - Optional network error details (e.g., original TypeError, fetch error).\n *\n * @returns {AirtableNetworkError} Error instance with name \"AirtableNetworkError\", status 503, and network error details.\n *\n * @example\n * // Error handling with retry logic\n * try {\n *   await client.listRecords(\"Tasks\");\n * } catch (err) {\n *   if (err instanceof AirtableNetworkError) {\n *     // Implement retry logic for network failures\n *     console.error(\"Network error. Retrying...\");\n *     await new Promise(resolve => setTimeout(resolve, 1000));\n *     return client.listRecords(\"Tasks\");\n *   }\n * }\n *\n * @remarks\n * Created automatically by airtableRequest when fetch throws network errors (TypeError, etc.).\n * Uses synthetic status 503 to normalize network errors with HTTP errors for consistent error handling.\n * Consider implementing retry logic with exponential backoff for network errors.\n *\n * @see AirtableHttpError\n * @see airtableRequest\n */\nexport class AirtableNetworkError extends AirtableHttpError {\n  constructor(args: { url: string; message: string; details?: unknown }) {\n    super({ status: 503, statusText: \"Network Error\", url: args.url, message: args.message, details: args.details });\n    this.name = \"AirtableNetworkError\";\n  }\n}\n\n/**\n * @name safeJsonParse\n * @kind Function\n * @summary Safely parses JSON string, returning undefined on parse errors instead of throwing.\n *\n * @description\n * Internal utility function that attempts to parse a JSON string.\n * Returns the parsed object if successful, or undefined if parsing fails.\n * Used to handle API responses that may or may not be valid JSON.\n * Prevents crashes when API returns non-JSON content (e.g., plain text errors).\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable\n *\n * @dependencies\n *\n * @performance\n * @complexity O(n) where n is string length - JSON.parse complexity\n * @latency Not applicable - synchronous function\n * @memory O(n) - creates parsed object\n * @rateLimit Not applicable\n * @notes Lightweight wrapper around JSON.parse with error handling.\n *\n * @security\n * @inputSanitization No sanitization - trusts input string. Returns undefined for invalid JSON.\n * @secretsHandling Not applicable\n * @pii Parsed JSON may contain PII depending on content\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {string} text - JSON string to parse.\n *\n * @returns {unknown | undefined} Parsed JSON object if successful, undefined if parse fails.\n *\n * @example\n * // Basic usage\n * const parsed = safeJsonParse('{\"key\": \"value\"}');\n * // Returns: { key: \"value\" }\n *\n * @example\n * // Handles invalid JSON\n * const parsed = safeJsonParse('invalid json');\n * // Returns: undefined\n *\n * @remarks\n * Internal function used by airtableRequest. Does not throw errors, returns undefined on failure.\n *\n * @see airtableRequest\n */\nfunction safeJsonParse(text: string): unknown {\n  try {\n    return JSON.parse(text);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * @name normalizeErrorMessage\n * @kind Function\n * @summary Normalizes error messages from Airtable API responses into readable format.\n *\n * @description\n * Internal utility function that extracts and formats error messages from Airtable API error responses.\n * Attempts to extract error type and message from Airtable error format: { error: { type, message } }.\n * Returns formatted string \"{type}: {message}\" if both available, \"{message}\" if only message available,\n * or \"{status} {statusText}\" as fallback. Used to create user-friendly error messages.\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - simple object property access\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates single string result\n * @rateLimit Not applicable\n * @notes Lightweight string formatting function.\n *\n * @security\n * @inputSanitization No sanitization - formats error messages as-is from API\n * @secretsHandling Not applicable\n * @pii Error messages may contain field names or record identifiers\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {number} status - HTTP status code from the API response.\n * @param {string} statusText - HTTP status text from the response.\n * @param {unknown} [details] - Optional parsed response body that may contain Airtable error structure.\n *\n * @returns {string} Normalized error message string in format \"{type}: {message}\", \"{message}\", or \"{status} {statusText}\".\n *\n * @example\n * // Basic usage with Airtable error format\n * const msg = normalizeErrorMessage(400, \"Bad Request\", {\n *   error: { type: \"INVALID_VALUE\", message: \"Field value is invalid\" }\n * });\n * // Returns: \"INVALID_VALUE: Field value is invalid\"\n *\n * @example\n * // Fallback to status text\n * const msg = normalizeErrorMessage(404, \"Not Found\");\n * // Returns: \"404 Not Found\"\n *\n * @remarks\n * Internal function used by airtableRequest. Handles Airtable-specific error format but falls back gracefully.\n *\n * @see airtableRequest\n * @see AirtableHttpError\n */\nfunction normalizeErrorMessage(status: number, statusText: string, details?: unknown): string {\n  // Airtable often returns: { error: { type, message } }\n  if (details && typeof details === \"object\") {\n    const anyDetails = details as any;\n    const msg = anyDetails?.error?.message;\n    const typ = anyDetails?.error?.type;\n    if (typeof msg === \"string\" && typeof typ === \"string\") return `${typ}: ${msg}`;\n    if (typeof msg === \"string\") return msg;\n  }\n  return `${status} ${statusText}`.trim();\n}\n\n/**\n * @name toSpecificError\n * @kind Function\n * @summary Converts generic AirtableHttpError to specific error type based on HTTP status code.\n *\n * @description\n * Internal utility function that maps HTTP status codes to specific error classes for better developer experience.\n * Converts status codes: 401/403 -> AirtableAuthError, 404 -> AirtableNotFoundError,\n * 422 -> AirtableValidationError, 429 -> AirtableRateLimitError.\n * Returns the original error if no specific mapping exists.\n * Used by airtableRequest to provide type-safe error handling.\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable\n *\n * @dependencies\n * @requires AirtableHttpError Base error class\n * @requires AirtableAuthError, AirtableRateLimitError, AirtableNotFoundError, AirtableValidationError Specific error classes\n *\n * @performance\n * @complexity O(1) - simple conditional checks\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates error instance\n * @rateLimit Not applicable\n * @notes Lightweight error mapping function.\n *\n * @security\n * @inputSanitization Not applicable - error object is passed through\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {AirtableHttpError} err - Base AirtableHttpError instance to convert.\n *\n * @returns {AirtableHttpError} Specific error instance (AirtableAuthError, AirtableRateLimitError, etc.) or original error if no mapping.\n *\n * @example\n * // Internal usage in airtableRequest\n * const baseErr = new AirtableHttpError({ status: 404, ... });\n * const specificErr = toSpecificError(baseErr);\n * // Returns: AirtableNotFoundError instance\n *\n * @remarks\n * Internal function used by airtableRequest. Provides better error types for type-safe error handling in catch blocks.\n *\n * @see airtableRequest\n * @see AirtableHttpError\n * @see AirtableAuthError\n * @see AirtableRateLimitError\n * @see AirtableNotFoundError\n * @see AirtableValidationError\n */\nfunction toSpecificError(err: AirtableHttpError): AirtableHttpError {\n  if (err.status === 401 || err.status === 403) return new AirtableAuthError(err);\n  if (err.status === 404) return new AirtableNotFoundError(err);\n  if (err.status === 422) return new AirtableValidationError(err);\n  if (err.status === 429) return new AirtableRateLimitError(err);\n  return err;\n}\n\n/**\n * @name airtableRequest\n * @kind AsyncFunction\n * @summary Makes HTTP requests to Airtable REST API with authentication, timeout handling, error normalization, and specific error types.\n *\n * @description\n * Async function that performs HTTP requests to Airtable REST API endpoints.\n * Handles authentication via Bearer token, request timeouts using AbortController,\n * JSON request/response parsing, and error normalization. Supports GET, POST, PATCH, and DELETE methods.\n * Automatically sets Content-Type header for requests with body. Parses JSON responses when content-type indicates JSON.\n * Throws specific error types (AirtableAuthError, AirtableRateLimitError, etc.) for better error handling.\n * Normalizes network errors to AirtableNetworkError. Returns parsed response data typed as TResponse.\n * Used internally by all client methods for API communication.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Valid Airtable API token with appropriate permissions\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - makes HTTP requests to Airtable API\n *\n * @dependencies\n * @requires safeJsonParse Internal function for safe JSON parsing\n * @requires normalizeErrorMessage Internal function for error message formatting\n * @requires toSpecificError Internal function for error type mapping\n *\n * @performance\n * @complexity O(1) - network-bound operation\n * @latency Network-bound: depends on API response time (typically 100-500ms, up to timeoutMs)\n * @memory O(1) - response data stored temporarily\n * @rateLimit Subject to Airtable API rate limits (typically 5 requests per second per base)\n * @notes Network-bound function. Timeout prevents hanging requests. Consider retry logic for production use.\n *\n * @security\n * @inputSanitization URL used directly in fetch. Body is JSON-stringified. Token included in Authorization header.\n * @secretsHandling Token included in Authorization header, never logged. Request details may be in error messages.\n * @pii Request/response may contain PII depending on table contents\n *\n * @compatibility\n * @supported Node.js 18+, modern browsers with fetch API\n * @notSupported Node.js < 18 without fetch polyfill\n *\n * @param {Object} args - Arguments object containing request configuration.\n * @param {string} args.url - Full URL for the Airtable API endpoint (including base URL, table path, and query params).\n * @param {\"GET\" | \"POST\" | \"PATCH\" | \"DELETE\"} args.method - HTTP method for the request.\n * @param {AirtableRequestConfig} args.config - Request configuration with token and timeoutMs.\n * @param {unknown} [args.body] - Optional request body. Will be JSON-stringified if provided. Omitted for GET requests.\n *\n * @returns {Promise<TResponse>} Promise resolving to parsed response data typed as TResponse. JSON if content-type is application/json, otherwise string.\n *\n * @throws {AirtableAuthError} When API returns 401 or 403 - authentication/authorization failure\n * @throws {AirtableNotFoundError} When API returns 404 - resource not found\n * @throws {AirtableValidationError} When API returns 422 - request validation failure\n * @throws {AirtableRateLimitError} When API returns 429 - rate limit exceeded\n * @throws {AirtableHttpError} When API returns other non-2xx status codes - generic HTTP error\n * @throws {AirtableHttpError} When request times out - status 408, message includes timeout duration\n * @throws {AirtableNetworkError} When network/transport failures occur - status 503, represents DNS/connection errors\n *\n * @example\n * // Basic usage - GET request\n * const response = await airtableRequest<AirtableListResponse>({\n *   url: \"https://api.airtable.com/v0/app123/Tasks\",\n *   method: \"GET\",\n *   config: { token: \"pat...\", timeoutMs: 15000 }\n * });\n *\n * @example\n * // Advanced usage - POST request with body\n * const record = await airtableRequest<AirtableRecord>({\n *   url: \"https://api.airtable.com/v0/app123/Tasks\",\n *   method: \"POST\",\n *   config: { token: \"pat...\", timeoutMs: 15000 },\n *   body: { fields: { Title: \"New Task\", Status: \"Open\" } }\n * });\n *\n * @example\n * // Error handling with specific error types\n * try {\n *   await airtableRequest({ url, method: \"GET\", config });\n * } catch (err) {\n *   if (err instanceof AirtableAuthError) {\n *     // Handle authentication error\n *   } else if (err instanceof AirtableRateLimitError) {\n *     // Implement retry with backoff\n *   } else if (err instanceof AirtableNetworkError) {\n *     // Handle network failure\n *   }\n * }\n *\n * @remarks\n * Request timeout is enforced using AbortController. Timeout errors are normalized to AirtableHttpError with status 408.\n * Response parsing: if content-type includes \"application/json\", attempts JSON parse; otherwise returns as string.\n * Error responses are parsed and normalized using Airtable error format when available.\n * Network errors (TypeError from fetch) are normalized to AirtableNetworkError with status 503.\n * Specific error types are automatically created based on HTTP status codes for better error handling.\n *\n * @see AirtableRequestConfig\n * @see AirtableHttpError\n * @see AirtableAuthError\n * @see AirtableRateLimitError\n * @see AirtableNotFoundError\n * @see AirtableValidationError\n * @see AirtableNetworkError\n */\nexport async function airtableRequest<TResponse>(args: {\n  url: string;\n  method: \"GET\" | \"POST\" | \"PATCH\" | \"DELETE\";\n  config: AirtableRequestConfig;\n  body?: unknown;\n}): Promise<TResponse> {\n  const { url, method, config, body } = args;\n\n  const controller = new AbortController();\n  const timeout = setTimeout(() => controller.abort(), config.timeoutMs);\n\n  try {\n    const res = await fetch(url, {\n      method,\n      signal: controller.signal,\n      headers: {\n        Authorization: `Bearer ${config.token}`,\n        \"Content-Type\": \"application/json\",\n      },\n      body: body === undefined ? undefined : JSON.stringify(body),\n    });\n\n    const contentType = res.headers.get(\"content-type\") ?? \"\";\n    const rawText = await res.text();\n    const parsed = contentType.includes(\"application/json\") ? safeJsonParse(rawText) : rawText;\n\n    if (!res.ok) {\n      const message = normalizeErrorMessage(res.status, res.statusText, parsed);\n      const baseErr = new AirtableHttpError({\n        status: res.status,\n        statusText: res.statusText,\n        url,\n        message,\n        details: parsed,\n      });\n      throw toSpecificError(baseErr);\n    }\n\n    return (parsed as TResponse) ?? (rawText as unknown as TResponse);\n  } catch (err: any) {\n    // Timeout / Abort normalization\n    if (err?.name === \"AbortError\") {\n      throw new AirtableHttpError({\n        status: 408,\n        statusText: \"Request Timeout\",\n        url,\n        message: `Request timed out after ${config.timeoutMs}ms`,\n      });\n    }\n\n    // If it's already normalized, keep it\n    if (err instanceof AirtableHttpError) {\n      throw err;\n    }\n\n    // Normalize fetch/network errors (TypeError in many runtimes)\n    const msg = typeof err?.message === \"string\" ? err.message : \"Network request failed\";\n    throw new AirtableNetworkError({ url, message: msg, details: err });\n  } finally {\n    clearTimeout(timeout);\n  }\n}\n","import type { AirtableListParams } from \"../../core/types/airtable\";\n\n/**\n * @name DEFAULT_AIRTABLE_API_URL\n * @kind Module\n * @summary Default base URL constant for Airtable REST API v0 endpoint.\n *\n * @description\n * Constant string representing the default base URL for Airtable REST API v0.\n * Used as fallback when apiUrl is not provided in AirtableClientConfig.\n * Points to the official Airtable API endpoint for version 0.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not specified\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - constant value\n * @latency Not applicable\n * @memory Not applicable\n * @rateLimit Not applicable\n * @notes Not applicable\n *\n * @security\n * @inputSanitization Not applicable\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All environments\n * @notSupported None\n *\n * @example\n * // Basic usage\n * const apiUrl = config.apiUrl ?? DEFAULT_AIRTABLE_API_URL;\n *\n * @remarks\n * Value: \"https://api.airtable.com/v0\". Can be overridden in client configuration for custom endpoints or testing.\n *\n * @see AirtableClientConfig\n */\nexport const DEFAULT_AIRTABLE_API_URL = \"https://api.airtable.com/v0\";\n\n/**\n * @name buildBaseUrl\n * @kind Function\n * @summary Constructs the base URL for Airtable API requests by combining API URL with base ID.\n *\n * @description\n * Utility function that builds the base URL for Airtable API requests.\n * Removes trailing slashes from apiUrl, then appends the URL-encoded baseId.\n * Result is used as the base path for all table and record endpoint URLs.\n * Ensures proper URL formatting and encoding for safe HTTP requests.\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable - pure string manipulation\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - simple string operations\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates single string result\n * @rateLimit Not applicable\n * @notes Lightweight string manipulation function.\n *\n * @security\n * @inputSanitization baseId is URL-encoded using encodeURIComponent to prevent injection\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {string} apiUrl - Base API URL (e.g., \"https://api.airtable.com/v0\"). Trailing slashes are removed.\n * @param {string} baseId - Airtable base identifier. Will be URL-encoded in the result.\n *\n * @returns {string} Combined URL string: \"{trimmedApiUrl}/{encodedBaseId}\".\n *\n * @example\n * // Basic usage\n * const baseUrl = buildBaseUrl(\"https://api.airtable.com/v0\", \"app123abc\");\n * // Returns: \"https://api.airtable.com/v0/app123abc\"\n *\n * @example\n * // Handles trailing slashes\n * const baseUrl = buildBaseUrl(\"https://api.airtable.com/v0/\", \"app123abc\");\n * // Returns: \"https://api.airtable.com/v0/app123abc\"\n *\n * @remarks\n * The baseId is URL-encoded to handle special characters safely. Trailing slashes in apiUrl are normalized.\n *\n * @see buildTablePath\n * @see buildRecordPath\n */\nexport function buildBaseUrl(apiUrl: string, baseId: string): string {\n  const trimmed = apiUrl.replace(/\\/+$/, \"\");\n  return `${trimmed}/${encodeURIComponent(baseId)}`;\n}\n\n/**\n * @name buildTablePath\n * @kind Function\n * @summary Constructs the URL path segment for a table endpoint by encoding the table name.\n *\n * @description\n * Utility function that builds the URL path segment for table-level operations.\n * Takes a table name and returns a path string with URL-encoded table name.\n * Used to construct endpoints for list and create operations on tables.\n * Table name is URL-encoded for safety, even though Airtable may accept raw names.\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable - pure string manipulation\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - simple string operations\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates single string result\n * @rateLimit Not applicable\n * @notes Lightweight string manipulation function.\n *\n * @security\n * @inputSanitization tableName is URL-encoded using encodeURIComponent to prevent injection\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {string} tableName - Name of the Airtable table. Will be URL-encoded in the result.\n *\n * @returns {string} Path string: \"/{encodedTableName}\".\n *\n * @example\n * // Basic usage\n * const path = buildTablePath(\"Tasks\");\n * // Returns: \"/Tasks\"\n *\n * @example\n * // Handles special characters\n * const path = buildTablePath(\"My Table\");\n * // Returns: \"/My%20Table\"\n *\n * @remarks\n * Table name is URL-encoded for safety. Result is a path segment, not a full URL. Combine with baseUrl for complete endpoint.\n *\n * @see buildBaseUrl\n * @see buildRecordPath\n */\nexport function buildTablePath(tableName: string): string {\n  // Airtable expects the raw table name in the path; we still encode it for safety.\n  return `/${encodeURIComponent(tableName)}`;\n}\n\n/**\n * @name buildRecordPath\n * @kind Function\n * @summary Constructs the URL path segment for a record endpoint by combining table name and record ID.\n *\n * @description\n * Utility function that builds the URL path segment for record-level operations (get, update, delete).\n * Combines table path with URL-encoded record ID to create the full record endpoint path.\n * Used to construct endpoints for operations on specific records within a table.\n * Both table name and record ID are URL-encoded for safety.\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable - pure string manipulation\n *\n * @dependencies\n * @requires buildTablePath Function to build table path segment\n *\n * @performance\n * @complexity O(1) - simple string operations\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates single string result\n * @rateLimit Not applicable\n * @notes Lightweight string manipulation function.\n *\n * @security\n * @inputSanitization Both tableName and recordId are URL-encoded using encodeURIComponent to prevent injection\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {string} tableName - Name of the Airtable table. Will be URL-encoded.\n * @param {string} recordId - Airtable record identifier. Will be URL-encoded in the result.\n *\n * @returns {string} Path string: \"/{encodedTableName}/{encodedRecordId}\".\n *\n * @example\n * // Basic usage\n * const path = buildRecordPath(\"Tasks\", \"rec123abc\");\n * // Returns: \"/Tasks/rec123abc\"\n *\n * @example\n * // Used in client methods\n * const url = `${baseUrl}${buildRecordPath(\"Users\", recordId)}`;\n *\n * @remarks\n * Both parameters are URL-encoded for safety. Result is a path segment, not a full URL. Combine with baseUrl for complete endpoint.\n *\n * @see buildBaseUrl\n * @see buildTablePath\n */\nexport function buildRecordPath(tableName: string, recordId: string): string {\n  return `${buildTablePath(tableName)}/${encodeURIComponent(recordId)}`;\n}\n\n/**\n * @name buildListQuery\n * @kind Function\n * @summary Constructs URL query string from AirtableListParams for list endpoint requests.\n *\n * @description\n * Utility function that converts AirtableListParams object into a URL query string.\n * Handles all supported list parameters: view, filterByFormula, maxRecords, pageSize, offset, and sort.\n * For sort parameters, builds array-style query params (sort[0][field], sort[0][direction], etc.).\n * Returns empty string if no params provided, or query string prefixed with \"?\" if params exist.\n * Used to append query parameters to list endpoint URLs.\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable - pure string manipulation\n *\n * @dependencies\n * @requires ../../core/types/airtable AirtableListParams type definition\n *\n * @performance\n * @complexity O(n) where n is number of sort items - iterates through sort array\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates single string result\n * @rateLimit Not applicable\n * @notes Lightweight function. Complexity is linear with number of sort parameters.\n *\n * @security\n * @inputSanitization All values are added to URLSearchParams which handles encoding automatically\n * @secretsHandling Not applicable\n * @pii filterByFormula may contain field references that could expose PII in query string\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments with URLSearchParams\n * @notSupported None\n *\n * @param {AirtableListParams} [params] - Optional query parameters object. If omitted, returns empty string.\n *\n * @returns {string} Empty string if no params, or query string prefixed with \"?\" (e.g., \"?view=Active&maxRecords=50\").\n *\n * @example\n * // Basic usage\n * const query = buildListQuery({ view: \"Active\", maxRecords: 50 });\n * // Returns: \"?view=Active&maxRecords=50\"\n *\n * @example\n * // Advanced usage with sorting\n * const query = buildListQuery({\n *   filterByFormula: \"{Status}='Open'\",\n *   sort: [\n *     { field: \"Created\", direction: \"desc\" },\n *     { field: \"Priority\", direction: \"asc\" }\n *   ]\n * });\n * // Returns: \"?filterByFormula={Status}='Open'&sort[0][field]=Created&sort[0][direction]=desc&sort[1][field]=Priority&sort[1][direction]=asc\"\n *\n * @remarks\n * URLSearchParams automatically handles encoding of special characters. Sort parameters use array notation for multi-level sorting.\n *\n * @see AirtableListParams\n * @see buildTablePath\n */\nexport function buildListQuery(params?: AirtableListParams): string {\n  if (!params) return \"\";\n\n  const q = new URLSearchParams();\n\n  if (params.view) q.set(\"view\", params.view);\n  if (params.filterByFormula) q.set(\"filterByFormula\", params.filterByFormula);\n  if (typeof params.maxRecords === \"number\") q.set(\"maxRecords\", String(params.maxRecords));\n  if (typeof params.pageSize === \"number\") q.set(\"pageSize\", String(params.pageSize));\n  if (params.offset) q.set(\"offset\", params.offset);\n\n  if (params.sort?.length) {\n    params.sort.forEach((s, i) => {\n      q.set(`sort[${i}][field]`, s.field);\n      if (s.direction) q.set(`sort[${i}][direction]`, s.direction);\n    });\n  }\n\n  const qs = q.toString();\n  return qs ? `?${qs}` : \"\";\n}\n","// # Imports\n// imports from core types\nimport type {\n  AirtableFields,\n  AirtableListParams,\n  AirtableListResponse,\n  AirtableRecord,\n  AirtableCreatePayload,\n  AirtableUpdatePayload,\n} from \"../../core/types/airtable\";\n// imports from server client request\nimport {\n  airtableRequest,\n  type AirtableRequestConfig,\n  AirtableHttpError,\n  AirtableNetworkError,\n} from \"./request\";\n// imports from server client endpoints\nimport {\n  DEFAULT_AIRTABLE_API_URL,\n  buildBaseUrl,\n  buildListQuery,\n  buildRecordPath,\n  buildTablePath,\n} from \"./endpoints\";\n\n/**\n * @name AirtableClientConfig\n * @kind Type\n * @summary Configuration object for creating an Airtable client with authentication and API settings.\n *\n * @description\n * Type definition for configuration options required to create an Airtable client instance.\n * Contains authentication token, base ID, and optional API URL and timeout settings.\n * Used by createAirtableClient to initialize a client with proper credentials and behavior.\n * All HTTP requests made by the client will use these settings.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Valid Airtable API token with appropriate base access\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - makes HTTP requests to Airtable API\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - type definition only\n * @latency Not applicable\n * @memory Not applicable\n * @rateLimit Not applicable\n * @notes Not applicable\n *\n * @security\n * @inputSanitization Token and baseId are used directly in HTTP requests\n * @secretsHandling Token should be kept secret and never logged. Stored in config object.\n * @pii Not applicable\n *\n * @compatibility\n * @supported Node.js 18+, modern browsers with fetch API\n * @notSupported Node.js < 18 without fetch polyfill\n *\n * @param {string} token - Airtable API personal access token or OAuth token. Required for authentication.\n * @param {string} baseId - Airtable base identifier. Required to target the correct base.\n * @param {string} [apiUrl] - Base URL for Airtable API. Defaults to \"https://api.airtable.com/v0\" if omitted.\n * @param {number} [timeoutMs] - Request timeout in milliseconds. Defaults to 15000ms (15 seconds) if omitted.\n *\n * @returns {Object} Object with required token and baseId, and optional apiUrl and timeoutMs properties.\n *\n * @example\n * // Basic usage\n * const config: AirtableClientConfig = {\n *   token: \"pat123...\",\n *   baseId: \"app123...\"\n * };\n *\n * @example\n * // Advanced usage with custom settings\n * const config: AirtableClientConfig = {\n *   token: process.env.AIRTABLE_TOKEN!,\n *   baseId: process.env.AIRTABLE_BASE_ID!,\n *   apiUrl: \"https://api.airtable.com/v0\",\n *   timeoutMs: 30000\n * };\n *\n * @remarks\n * The token must have appropriate permissions for the base. Keep tokens secure and never commit them to version control.\n *\n * @see createAirtableClient\n */\nexport type AirtableClientConfig = {\n  token: string;\n  baseId: string;\n  /**\n   * Defaults to https://api.airtable.com/v0\n   */\n  apiUrl?: string;\n  /**\n   * Defaults to 15000ms\n   */\n  timeoutMs?: number;\n};\n\n/**\n * @name AirtableClient\n * @kind Type\n * @summary Interface type defining methods for interacting with Airtable REST API (list, get, create, update, delete records).\n *\n * @description\n * Type definition representing an Airtable client instance with methods for CRUD operations.\n * Provides type-safe methods for listing, retrieving, creating, updating, and deleting records.\n * Includes listRecords and listPage methods (listPage is an alias for listRecords for semantic clarity).\n * All methods are generic over TFields to allow consumers to specify field shapes.\n * Returned by createAirtableClient after initialization with valid configuration.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Valid Airtable API token with appropriate base and table access\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - makes HTTP requests to Airtable API\n *\n * @dependencies\n * @requires ./request airtableRequest function for HTTP requests\n * @requires ./endpoints URL building utilities\n * @requires ../../core/types/airtable AirtableCreatePayload and AirtableUpdatePayload types for request bodies\n *\n * @performance\n * @complexity O(1) - type definition only\n * @latency Network-bound: depends on Airtable API response times (typically 100-500ms)\n * @memory Not applicable\n * @rateLimit Subject to Airtable API rate limits (typically 5 requests per second per base)\n * @notes All operations are network-bound. Consider batching and caching strategies for high-volume usage.\n *\n * @security\n * @inputSanitization Table names and record IDs are URL-encoded. Field values are JSON-stringified.\n * @secretsHandling Token is included in Authorization header, never logged\n * @pii May handle PII depending on table field contents\n *\n * @compatibility\n * @supported Node.js 18+, modern browsers with fetch API\n * @notSupported Node.js < 18 without fetch polyfill\n *\n * @returns {Object} Object with methods: listRecords, listPage, getRecord, createRecord, updateRecord, deleteRecord.\n *\n * @example\n * // Basic usage\n * const client = createAirtableClient({ token: \"pat...\", baseId: \"app...\" });\n * const records = await client.listRecords(\"Tasks\");\n *\n * @example\n * // Using listPage alias (same as listRecords)\n * const page = await client.listPage(\"Tasks\", { pageSize: 50 });\n *\n * @example\n * // Advanced usage with typed fields\n * type TaskFields = { Title: string; Status: string };\n * const record = await client.getRecord<TaskFields>(\"Tasks\", \"rec123\");\n *\n * @remarks\n * All methods return Promises and should be awaited. Methods are generic over TFields for type safety.\n * listPage is an alias for listRecords, provided for semantic clarity when fetching paginated results.\n * createRecord and updateRecord use AirtableCreatePayload and AirtableUpdatePayload types respectively.\n *\n * @see createAirtableClient\n * @see AirtableClientConfig\n */\nexport type AirtableClient = {\n  readonly baseId: string;\n  readonly apiUrl: string;\n\n  listRecords: <TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    params?: AirtableListParams,\n  ) => Promise<AirtableListResponse<TFields>>;\n\n  listPage: <TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    params?: AirtableListParams,\n  ) => Promise<AirtableListResponse<TFields>>;\n\n  getRecord: <TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    recordId: string,\n  ) => Promise<AirtableRecord<TFields>>;\n\n  createRecord: <TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    fields: Partial<TFields>,\n  ) => Promise<AirtableRecord<TFields>>;\n\n  updateRecord: <TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    recordId: string,\n    fields: Partial<TFields>,\n  ) => Promise<AirtableRecord<TFields>>;\n\n  deleteRecord: (\n    tableName: string,\n    recordId: string,\n  ) => Promise<{ id: string; deleted: boolean }>;\n\n  /**\n   * Makes a custom request to the Airtable API. Used internally for endpoints not covered by standard methods.\n   * @internal\n   */\n  _request: <TResponse = unknown>(\n    url: string,\n    method: \"GET\" | \"POST\" | \"PATCH\" | \"DELETE\",\n    body?: unknown,\n  ) => Promise<TResponse>;\n\n  /**\n   * Makes a multipart/form-data request to the Airtable API. Used for file uploads.\n   * @internal\n   */\n  _requestMultipart: <TResponse = unknown>(\n    url: string,\n    formData: FormData,\n  ) => Promise<TResponse>;\n};\n\n/**\n * @name createAirtableClient\n * @kind Function\n * @summary Creates and returns an Airtable client instance configured with provided settings for API interactions.\n *\n * @description\n * Factory function that creates an AirtableClient instance with methods for interacting with Airtable REST API.\n * Validates required configuration (token and baseId), sets defaults for optional settings (apiUrl, timeoutMs),\n * and initializes internal request configuration. Returns an object with CRUD methods for records.\n * All methods use the configured token and base ID for authentication and routing.\n * Creates listRecords and listPage methods (listPage is an alias for listRecords).\n * Uses AirtableCreatePayload and AirtableUpdatePayload types for request body validation.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Valid Airtable API token with appropriate base access\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - client makes HTTP requests to Airtable API\n *\n * @dependencies\n * @requires ./request airtableRequest function for HTTP requests\n * @requires ./endpoints URL building utilities (buildBaseUrl, buildTablePath, buildRecordPath, buildListQuery)\n * @requires ../../core/types/airtable AirtableCreatePayload and AirtableUpdatePayload types for request bodies\n *\n * @performance\n * @complexity O(1) - lightweight factory function, no heavy computation\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates client object with method closures\n * @rateLimit Not applicable\n * @notes Function execution is lightweight. Network operations happen when client methods are called.\n *\n * @security\n * @inputSanitization Validates token and baseId are provided (throws if missing). Values used directly in requests.\n * @secretsHandling Token stored in closure, never logged. Passed to airtableRequest in Authorization header.\n * @pii Not applicable\n *\n * @compatibility\n * @supported Node.js 18+, modern browsers with fetch API\n * @notSupported Node.js < 18 without fetch polyfill\n *\n * @param {AirtableClientConfig} config - Configuration object with token, baseId, and optional apiUrl and timeoutMs.\n *\n * @returns {AirtableClient} Client instance with methods: listRecords, listPage, getRecord, createRecord, updateRecord, deleteRecord.\n *\n * @throws {Error} When token is missing or empty - message: \"createAirtableClient: `token` is required\"\n * @throws {Error} When baseId is missing or empty - message: \"createAirtableClient: `baseId` is required\"\n *\n * @example\n * // Basic usage\n * const client = createAirtableClient({\n *   token: \"pat123...\",\n *   baseId: \"app456...\"\n * });\n * const records = await client.listRecords(\"Tasks\");\n *\n * @example\n * // Using listPage alias\n * const page = await client.listPage(\"Tasks\", { pageSize: 50, offset: \"itr123\" });\n *\n * @example\n * // Advanced usage with custom settings\n * const client = createAirtableClient({\n *   token: process.env.AIRTABLE_TOKEN!,\n *   baseId: process.env.AIRTABLE_BASE_ID!,\n *   apiUrl: \"https://api.airtable.com/v0\",\n *   timeoutMs: 30000\n * });\n * const record = await client.getRecord(\"Users\", \"rec789\");\n *\n * @remarks\n * The client instance maintains configuration in closures. Token and baseId are validated at creation time.\n * All client methods are async and return Promises. Network errors are thrown as AirtableHttpError.\n * listPage is an alias for listRecords, provided for semantic clarity when working with pagination.\n * createRecord and updateRecord use type assertions with AirtableCreatePayload and AirtableUpdatePayload respectively.\n *\n * @see AirtableClientConfig\n * @see AirtableClient\n */\nexport function createAirtableClient(\n  config: AirtableClientConfig,\n): AirtableClient {\n  const apiUrl = config.apiUrl ?? DEFAULT_AIRTABLE_API_URL;\n  const timeoutMs = config.timeoutMs ?? 15000;\n\n  if (!config.token)\n    throw new Error(\"createAirtableClient: `token` is required\");\n  if (!config.baseId)\n    throw new Error(\"createAirtableClient: `baseId` is required\");\n\n  const baseUrl = buildBaseUrl(apiUrl, config.baseId);\n\n  const reqConfig: AirtableRequestConfig = {\n    token: config.token,\n    timeoutMs,\n  };\n\n  async function listRecords<TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    params?: AirtableListParams,\n  ): Promise<AirtableListResponse<TFields>> {\n    const url = `${baseUrl}${buildTablePath(tableName)}${buildListQuery(params)}`;\n    return airtableRequest<AirtableListResponse<TFields>>({\n      url,\n      method: \"GET\",\n      config: reqConfig,\n    });\n  }\n\n  return {\n    baseId: config.baseId,\n    apiUrl,\n\n    listRecords,\n    listPage: listRecords,\n\n    async getRecord<TFields extends AirtableFields = AirtableFields>(\n      tableName: string,\n      recordId: string,\n    ): Promise<AirtableRecord<TFields>> {\n      const url = `${baseUrl}${buildRecordPath(tableName, recordId)}`;\n      return airtableRequest<AirtableRecord<TFields>>({\n        url,\n        method: \"GET\",\n        config: reqConfig,\n      });\n    },\n\n    async createRecord<TFields extends AirtableFields = AirtableFields>(\n      tableName: string,\n      fields: Partial<TFields>,\n    ): Promise<AirtableRecord<TFields>> {\n      const url = `${baseUrl}${buildTablePath(tableName)}`;\n      return airtableRequest<AirtableRecord<TFields>>({\n        url,\n        method: \"POST\",\n        config: reqConfig,\n        body: { fields } as AirtableCreatePayload<TFields>,\n      });\n    },\n\n    async updateRecord<TFields extends AirtableFields = AirtableFields>(\n      tableName: string,\n      recordId: string,\n      fields: Partial<TFields>,\n    ): Promise<AirtableRecord<TFields>> {\n      const url = `${baseUrl}${buildRecordPath(tableName, recordId)}`;\n      return airtableRequest<AirtableRecord<TFields>>({\n        url,\n        method: \"PATCH\",\n        config: reqConfig,\n        body: { fields } as AirtableUpdatePayload<TFields>,\n      });\n    },\n\n    async deleteRecord(\n      tableName: string,\n      recordId: string,\n    ): Promise<{ id: string; deleted: boolean }> {\n      const url = `${baseUrl}${buildRecordPath(tableName, recordId)}`;\n      return airtableRequest<{ id: string; deleted: boolean }>({\n        url,\n        method: \"DELETE\",\n        config: reqConfig,\n      });\n    },\n\n    async _request<TResponse = unknown>(\n      url: string,\n      method: \"GET\" | \"POST\" | \"PATCH\" | \"DELETE\",\n      body?: unknown,\n    ): Promise<TResponse> {\n      return airtableRequest<TResponse>({\n        url,\n        method,\n        config: reqConfig,\n        body,\n      });\n    },\n\n    async _requestMultipart<TResponse = unknown>(\n      url: string,\n      formData: FormData,\n    ): Promise<TResponse> {\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), reqConfig.timeoutMs);\n\n      try {\n        const res = await fetch(url, {\n          method: \"POST\",\n          signal: controller.signal,\n          headers: {\n            Authorization: `Bearer ${reqConfig.token}`,\n            // Don't set Content-Type - browser/fetch will set it with boundary for multipart/form-data\n          },\n          body: formData,\n        });\n\n        const contentType = res.headers.get(\"content-type\") ?? \"\";\n        const rawText = await res.text();\n        const parsed = contentType.includes(\"application/json\")\n          ? (JSON.parse(rawText) as unknown)\n          : rawText;\n\n        if (!res.ok) {\n          const message =\n            typeof parsed === \"object\" &&\n            parsed !== null &&\n            \"error\" in parsed &&\n            typeof (parsed as any).error === \"object\" &&\n            (parsed as any).error?.message\n              ? (parsed as any).error.message\n              : `Request failed with status ${res.status}`;\n          const baseErr = new AirtableHttpError({\n            status: res.status,\n            statusText: res.statusText,\n            url,\n            message,\n            details: parsed,\n          });\n          throw baseErr;\n        }\n\n        return (parsed as TResponse) ?? (rawText as unknown as TResponse);\n      } catch (err: any) {\n        // Timeout / Abort normalization\n        if (err?.name === \"AbortError\") {\n          throw new AirtableHttpError({\n            status: 408,\n            statusText: \"Request Timeout\",\n            url,\n            message: `Request timed out after ${reqConfig.timeoutMs}ms`,\n          });\n        }\n\n        // If it's already an AirtableHttpError, keep it\n        if (err instanceof AirtableHttpError) {\n          throw err;\n        }\n\n        // Normalize fetch/network errors\n        const msg = typeof err?.message === \"string\" ? err.message : \"Network request failed\";\n        throw new AirtableNetworkError({ url, message: msg, details: err });\n      } finally {\n        clearTimeout(timeout);\n      }\n    },\n  };\n}","import type {\n  AirtableFields,\n  AirtableListParams,\n  AirtableListResponse,\n  AirtableRecord,\n} from \"../../core/types/airtable\";\nimport type { AirtableClient } from \"./createClient\";\n\n/**\n * @name AirtableListAllOptions\n * @kind Type\n * @summary Configuration options for auto-pagination when fetching all records from a table.\n *\n * @description\n * Type definition for options controlling the behavior of listAllRecords function.\n * Provides safety limits to prevent accidental retrieval of extremely large datasets.\n * Used to configure maximum record limits and prevent infinite loops or memory issues.\n * All fields are optional with sensible defaults.\n *\n * @category Data\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not specified\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - type definition only\n * @latency Not applicable\n * @memory Not applicable\n * @rateLimit Not applicable\n * @notes Not applicable\n *\n * @security\n * @inputSanitization Not specified\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All TypeScript/JavaScript environments\n * @notSupported None\n *\n * @param {number} [maxTotalRecords] - Maximum total records to fetch across all pages. Defaults to 10000 if omitted. Prevents accidental huge pulls.\n *\n * @returns {Object} Object with optional maxTotalRecords property.\n *\n * @example\n * // Basic usage with default limit\n * const options: AirtableListAllOptions = {};\n *\n * @example\n * // Advanced usage with custom limit\n * const options: AirtableListAllOptions = {\n *   maxTotalRecords: 5000\n * };\n *\n * @remarks\n * The maxTotalRecords limit is a safety mechanism. If exceeded, listAllRecords throws an error suggesting to add filters.\n *\n * @see listAllRecords\n */\nexport type AirtableListAllOptions = {\n  /**\n   * Safety cap to prevent accidental infinite loops / huge pulls.\n   * Defaults to 10_000.\n   */\n  maxTotalRecords?: number;\n};\n\n/**\n * @name listAllRecords\n * @kind AsyncFunction\n * @summary Fetches all records from an Airtable table by automatically following pagination offsets until all records are retrieved.\n *\n * @description\n * Async function that retrieves all records from a table by automatically paginating through Airtable API responses.\n * Makes repeated calls to client.listRecords, following the offset token from each response until no more pages remain.\n * Accumulates all records into a single array and returns them. Includes safety limit to prevent accidental huge pulls.\n * Respects filterByFormula and view parameters to reduce payload size. Generic over TFields for type safety.\n * Throws error if maxTotalRecords limit is exceeded, suggesting to add filters.\n *\n * @category Data\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Valid Airtable API token with appropriate table access\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - makes multiple HTTP requests to Airtable API\n *\n * @dependencies\n * @requires ./createClient AirtableClient type and instance\n * @requires ../../core/types/airtable AirtableFields, AirtableListParams, AirtableListResponse, AirtableRecord types\n *\n * @performance\n * @complexity O(n/p) where n is total records and p is page size - makes n/p API calls\n * @latency Network-bound: depends on number of pages and API response times (typically 100-500ms per page)\n * @memory O(n) - accumulates all records in memory array\n * @rateLimit Subject to Airtable API rate limits (typically 5 requests per second per base). Multiple pages = multiple requests.\n * @notes For large tables, consider using filters to reduce payload. Each page requires a separate API call.\n *\n * @security\n * @inputSanitization tableName and params passed through to client.listRecords which handles encoding\n * @secretsHandling Token handled by client, never logged\n * @pii May return PII depending on table field contents\n *\n * @compatibility\n * @supported Node.js 18+, modern browsers with fetch API\n * @notSupported Node.js < 18 without fetch polyfill\n *\n * @param {Object} args - Arguments object containing client, tableName, params, and options.\n * @param {AirtableClient} args.client - Airtable client instance for making API requests.\n * @param {string} args.tableName - Name of the Airtable table to fetch records from.\n * @param {Omit<AirtableListParams, \"offset\">} [args.params] - Query parameters (offset is excluded as it's managed internally). Use filterByFormula or view to reduce payload.\n * @param {AirtableListAllOptions} [args.options] - Options for controlling pagination behavior. Defaults to maxTotalRecords: 10000.\n *\n * @returns {Promise<Array<AirtableRecord<TFields>>>} Promise resolving to array of all records from the table.\n *\n * @throws {Error} When maxTotalRecords limit is exceeded - message includes limit value and suggests adding filters\n *\n * @example\n * // Basic usage\n * const allRecords = await listAllRecords({\n *   client,\n *   tableName: \"Tasks\"\n * });\n *\n * @example\n * // Advanced usage with filters and custom limit\n * const openTasks = await listAllRecords({\n *   client,\n *   tableName: \"Tasks\",\n *   params: {\n *     filterByFormula: \"{Status}='Open'\",\n *     sort: [{ field: \"Created\", direction: \"desc\" }]\n *   },\n *   options: { maxTotalRecords: 5000 }\n * });\n *\n * @remarks\n * Airtable may enforce its own max limits depending on plan. Use filterByFormula and view to reduce payload.\n * This function makes multiple API calls (one per page), so be mindful of rate limits for large tables.\n *\n * @see AirtableClient\n * @see AirtableListAllOptions\n * @see AirtableListParams\n */\nexport async function listAllRecords<\n  TFields extends AirtableFields = AirtableFields,\n>(args: {\n  client: AirtableClient;\n  tableName: string;\n  params?: Omit<AirtableListParams, \"offset\">;\n  options?: AirtableListAllOptions;\n}): Promise<Array<AirtableRecord<TFields>>> {\n  const { client, tableName, params, options } = args;\n\n  const maxTotalRecords = options?.maxTotalRecords ?? 10_000;\n\n  const out: Array<AirtableRecord<TFields>> = [];\n  let offset: string | undefined = undefined;\n\n  while (true) {\n    const page: AirtableListResponse<TFields> = await client.listRecords<TFields>(tableName, {\n      ...(params ?? {}),\n      offset,\n    });\n\n    out.push(...page.records);\n\n    if (out.length > maxTotalRecords) {\n      throw new Error(\n        `listAllRecords: exceeded maxTotalRecords (${maxTotalRecords}). ` +\n          `Add filters or increase the limit explicitly.`,\n      );\n    }\n\n    if (!page.offset) break;\n    offset = page.offset;\n  }\n\n  return out;\n}\n","import type { AirtableClient } from \"./createClient\";\nimport type { AirtableFields } from \"../../core/types/airtable\";\nimport { promises as fs } from \"fs\";\nimport { extname } from \"path\";\nimport {\n  AirtableHttpError,\n  AirtableNetworkError,\n  AirtableAuthError,\n  AirtableNotFoundError,\n  AirtableValidationError,\n  AirtableRateLimitError,\n} from \"./request\";\n\n/**\n * @name AirtableAttachment\n * @kind Type\n * @summary Type definition for Airtable attachment objects.\n *\n * @description\n * Type definition representing an attachment object in Airtable attachment fields.\n * Supports both public URLs and local file paths. For URLs, attachments are stored as arrays\n * of objects with url, filename, size, and type properties. For local files, the filePath\n * is used to read and upload the file via Airtable's uploadAttachment endpoint.\n * Used when adding attachments to records via the API.\n *\n * @category Data\n * @since Not specified\n *\n * @param {string} [url] - Public URL of the attachment file. Must be directly downloadable. Required if filePath is not provided.\n * @param {string} [filePath] - Local file path to upload. File will be read from filesystem and uploaded as base64. Required if url is not provided. Only works in Node.js environment.\n * @param {string} [filename] - Optional filename for the attachment. If not provided and filePath is used, extracted from filePath.\n * @param {number} [size] - Optional file size in bytes.\n * @param {string} [type] - Optional MIME type of the file (e.g., \"application/pdf\", \"image/png\"). If not provided, inferred from file extension.\n *\n * @example\n * // Basic usage with URL\n * const attachment: AirtableAttachment = {\n *   url: \"https://example.com/document.pdf\",\n *   filename: \"document.pdf\",\n *   type: \"application/pdf\"\n * };\n *\n * @example\n * // Usage with local file (Node.js only)\n * const attachment: AirtableAttachment = {\n *   filePath: \"/path/to/local/document.pdf\",\n *   filename: \"document.pdf\",\n *   type: \"application/pdf\"\n * };\n *\n * @remarks\n * Either url or filePath must be provided. The URL must be publicly accessible and directly downloadable.\n * For local files, Airtable will upload the file via the uploadAttachment endpoint (max 5MB).\n * For PDFs, use type: \"application/pdf\". For images, use appropriate image MIME types.\n * If type is not provided and filePath is used, it will be inferred from the file extension.\n */\nexport type AirtableAttachment = {\n  url?: string;\n  filePath?: string;\n  filename?: string;\n  size?: number;\n  type?: string;\n};\n\n/**\n * Maximum file size for uploadAttachment endpoint (5MB in bytes)\n */\nconst MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB\n\n/**\n * MIME type mapping based on file extensions\n */\nconst MIME_TYPES: Record<string, string> = {\n  \".pdf\": \"application/pdf\",\n  \".png\": \"image/png\",\n  \".jpg\": \"image/jpeg\",\n  \".jpeg\": \"image/jpeg\",\n  \".gif\": \"image/gif\",\n  \".webp\": \"image/webp\",\n  \".svg\": \"image/svg+xml\",\n  \".txt\": \"text/plain\",\n  \".csv\": \"text/csv\",\n  \".json\": \"application/json\",\n  \".xml\": \"application/xml\",\n  \".zip\": \"application/zip\",\n  \".doc\": \"application/msword\",\n  \".docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n  \".xls\": \"application/vnd.ms-excel\",\n  \".xlsx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n  \".ppt\": \"application/vnd.ms-powerpoint\",\n  \".pptx\": \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n};\n\n/**\n * Infers MIME type from file extension\n */\nfunction getMimeTypeFromExtension(filePath: string): string {\n  const ext = extname(filePath).toLowerCase();\n  return MIME_TYPES[ext] || \"application/octet-stream\";\n}\n\n/**\n * Reads a local file and converts it to base64\n */\nasync function readFileAsBase64(filePath: string): Promise<{ base64: string; size: number }> {\n  try {\n    const buffer = await fs.readFile(filePath);\n    const size = buffer.length;\n\n    if (size > MAX_FILE_SIZE) {\n      throw new Error(\n        `File size (${size} bytes) exceeds maximum allowed size of ${MAX_FILE_SIZE} bytes (5MB)`,\n      );\n    }\n\n    const base64 = buffer.toString(\"base64\");\n    return { base64, size };\n  } catch (error: any) {\n    if (error.code === \"ENOENT\") {\n      throw new Error(`File not found: ${filePath}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Extracts filename from file path\n */\nfunction getFilenameFromPath(filePath: string): string {\n  const parts = filePath.split(/[/\\\\]/);\n  return parts[parts.length - 1] || \"file\";\n}\n\n/**\n * Checks if a string is a URL (starts with http:// or https://)\n */\nfunction isUrl(str: string): boolean {\n  return str.startsWith(\"http://\") || str.startsWith(\"https://\");\n}\n\n/**\n * Uploads a local file to Airtable using the uploadAttachment endpoint\n * \n * Note: \n * - This endpoint expects JSON (not multipart): { contentType, file (base64), filename }\n * - The endpoint URL uses content.airtable.com, not api.airtable.com\n * - The endpoint accepts fieldId (like \"fldXXXXXXXXXXXXXX\") or fieldName\n * - FieldId is more reliable, but fieldName may work in some cases\n * \n * @throws {Error} When file validation fails (not found, too large, permission denied, etc.)\n * @throws {AirtableHttpError} When API returns HTTP errors (400, 401, 403, 404, 422, 429, 500, etc.)\n * @throws {AirtableNetworkError} When network/transport failures occur\n */\nasync function uploadLocalFile<TFields extends AirtableFields = AirtableFields>(\n  client: AirtableClient,\n  tableName: string,\n  recordId: string,\n  fieldName: string,\n  filePath: string,\n  filename?: string,\n  contentType?: string,\n): Promise<import(\"../../core/types/airtable\").AirtableRecord<TFields>> {\n  // Validate input parameters\n  if (!tableName || typeof tableName !== \"string\" || tableName.trim().length === 0) {\n    throw new Error(\n      `uploadLocalFile: Invalid tableName. Expected non-empty string, got: ${JSON.stringify(tableName)}`,\n    );\n  }\n  if (!recordId || typeof recordId !== \"string\" || recordId.trim().length === 0) {\n    throw new Error(\n      `uploadLocalFile: Invalid recordId. Expected non-empty string, got: ${JSON.stringify(recordId)}`,\n    );\n  }\n  if (!fieldName || typeof fieldName !== \"string\" || fieldName.trim().length === 0) {\n    throw new Error(\n      `uploadLocalFile: Invalid fieldName. Expected non-empty string, got: ${JSON.stringify(fieldName)}`,\n    );\n  }\n  if (!filePath || typeof filePath !== \"string\" || filePath.trim().length === 0) {\n    throw new Error(\n      `uploadLocalFile: Invalid filePath. Expected non-empty string, got: ${JSON.stringify(filePath)}`,\n    );\n  }\n\n  // Determine filename\n  const finalFilename = filename || getFilenameFromPath(filePath);\n  if (!finalFilename || finalFilename.trim().length === 0) {\n    throw new Error(\n      `uploadLocalFile: Cannot determine filename from filePath \"${filePath}\". Please provide a valid filename parameter.`,\n    );\n  }\n\n  // Determine content type\n  const finalContentType = contentType || getMimeTypeFromExtension(filePath);\n\n  // Validate and read file stats\n  let stats: import(\"fs\").Stats;\n  try {\n    stats = await fs.stat(filePath);\n  } catch (error: any) {\n    // Handle filesystem errors with detailed messages\n    if (error.code === \"ENOENT\") {\n      throw new Error(\n        `uploadLocalFile: File not found at path \"${filePath}\". Please verify the file exists and the path is correct.`,\n      );\n    }\n    if (error.code === \"EACCES\") {\n      throw new Error(\n        `uploadLocalFile: Permission denied accessing file \"${filePath}\". Please check file permissions.`,\n      );\n    }\n    if (error.code === \"EISDIR\") {\n      throw new Error(\n        `uploadLocalFile: Path \"${filePath}\" is a directory, not a file. Please provide a file path.`,\n      );\n    }\n    if (error.code === \"EMFILE\" || error.code === \"ENFILE\") {\n      throw new Error(\n        `uploadLocalFile: Too many open files. System limit reached. Please close other file handles and try again.`,\n      );\n    }\n    // Generic filesystem error\n    throw new Error(\n      `uploadLocalFile: Failed to access file \"${filePath}\": ${error.message || error.code || \"Unknown error\"}`,\n    );\n  }\n\n  // Check if it's a file (not a directory)\n  if (!stats.isFile()) {\n    throw new Error(\n      `uploadLocalFile: Path \"${filePath}\" is not a regular file (isDirectory: ${stats.isDirectory()}, isSymbolicLink: ${stats.isSymbolicLink()}).`,\n    );\n  }\n\n  // Check file size\n  if (stats.size > MAX_FILE_SIZE) {\n    const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);\n    const maxMB = (MAX_FILE_SIZE / (1024 * 1024)).toFixed(0);\n    throw new Error(\n      `uploadLocalFile: File size (${stats.size} bytes, ${sizeMB} MB) exceeds maximum allowed size of ${MAX_FILE_SIZE} bytes (${maxMB} MB). ` +\n        `Please use a smaller file or compress the file before uploading.`,\n    );\n  }\n\n  // Check if file is empty\n  if (stats.size === 0) {\n    throw new Error(\n      `uploadLocalFile: File \"${filePath}\" is empty (0 bytes). Cannot upload empty files.`,\n    );\n  }\n\n  // Build upload URL: POST https://content.airtable.com/v0/{baseId}/{recordId}/{fieldId}/uploadAttachment\n  // Note: uploadAttachment endpoint uses content.airtable.com, not api.airtable.com\n  // The endpoint accepts fieldId (field ID like \"fldXXXXXXXXXXXXXX\") or fieldName\n  // FieldId is preferred and more reliable, but we'll try with fieldName for convenience\n  // If fieldName doesn't work, users should pass the fieldId instead\n  let uploadUrl: string;\n  try {\n    const contentApiUrl = client.apiUrl.replace(\"api.airtable.com\", \"content.airtable.com\").replace(/\\/+$/, \"\");\n    const encodedBaseId = encodeURIComponent(client.baseId);\n    const encodedRecordId = encodeURIComponent(recordId);\n    const encodedFieldName = encodeURIComponent(fieldName);\n    uploadUrl = `${contentApiUrl}/${encodedBaseId}/${encodedRecordId}/${encodedFieldName}/uploadAttachment`;\n  } catch (error: any) {\n    throw new Error(\n      `uploadLocalFile: Failed to build upload URL: ${error.message || \"Unknown error\"}. ` +\n        `baseId: \"${client.baseId}\", recordId: \"${recordId}\", fieldName: \"${fieldName}\"`,\n    );\n  }\n\n  // Read file as Buffer\n  let base64: string;\n  try {\n    // Airtable uploadAttachment expects the file bytes as a base64 string (JSON body)\n    const res = await readFileAsBase64(filePath);\n    base64 = res.base64;\n  } catch (error: any) {\n    // Handle read errors with detailed messages\n    if (error.code === \"ENOENT\") {\n      throw new Error(\n        `uploadLocalFile: File not found at path \"${filePath}\" while reading. File may have been deleted.`,\n      );\n    }\n    if (error.code === \"EACCES\") {\n      throw new Error(\n        `uploadLocalFile: Permission denied reading file \"${filePath}\". Please check file read permissions.`,\n      );\n    }\n    if (error.code === \"EISDIR\") {\n      throw new Error(\n        `uploadLocalFile: Cannot read \"${filePath}\" - it is a directory, not a file.`,\n      );\n    }\n    if (error.code === \"EMFILE\" || error.code === \"ENFILE\") {\n      throw new Error(\n        `uploadLocalFile: Too many open files while reading \"${filePath}\". System limit reached.`,\n      );\n    }\n    // Generic read error\n    throw new Error(\n      `uploadLocalFile: Failed to read file \"${filePath}\": ${error.message || error.code || \"Unknown error\"}`,\n    );\n  }\n\n  // Validate base64 was read correctly\n  if (!base64 || base64.length === 0) {\n    throw new Error(\n      `uploadLocalFile: File \"${filePath}\" appears to be empty or could not be read properly.`,\n    );\n  }\n\n  // Make the upload request using JSON body as documented by Airtable:\n  // POST https://content.airtable.com/v0/{baseId}/{recordId}/{attachmentFieldIdOrName}/uploadAttachment\n  // Body: { contentType, file (base64), filename }\n  try {\n    const response = await client._request<import(\"../../core/types/airtable\").AirtableRecord<TFields>>(\n      uploadUrl,\n      \"POST\",\n      {\n        contentType: finalContentType,\n        file: base64,\n        filename: finalFilename,\n      },\n    );\n    return response;\n  } catch (error: any) {\n    // Enhance HTTP errors with upload-specific context\n    if (error instanceof AirtableHttpError) {\n      // Create enhanced error message with upload context\n      const contextInfo = `Upload failed for file \"${finalFilename}\" (${stats.size} bytes, ${finalContentType}) ` +\n        `to table \"${tableName}\", record \"${recordId}\", field \"${fieldName}\"`;\n      \n      let enhancedMessage: string;\n      \n      // Provide specific guidance based on error type\n      if (error instanceof AirtableAuthError) {\n        enhancedMessage = `${contextInfo}. Authentication failed (${error.status}): ${error.message}. ` +\n          `Please verify your Airtable API token has write permissions for this base.`;\n      } else if (error instanceof AirtableNotFoundError) {\n        enhancedMessage = `${contextInfo}. Resource not found (${error.status}): ${error.message}. ` +\n          `Please verify that: 1) The base ID \"${client.baseId}\" is correct, ` +\n          `2) The record ID \"${recordId}\" exists, ` +\n          `3) The table \"${tableName}\" exists, ` +\n          `4) The field \"${fieldName}\" exists and is an attachment field. ` +\n          `Note: If using fieldName, try using the fieldId (e.g., \"fldXXXXXXXXXXXXXX\") instead.`;\n      } else if (error instanceof AirtableValidationError) {\n        enhancedMessage = `${contextInfo}. Validation failed (${error.status}): ${error.message}. ` +\n          `Common causes: 1) Field \"${fieldName}\" is not an attachment field, ` +\n          `2) File format or size is not supported, ` +\n          `3) Field name is invalid (try using fieldId instead), ` +\n          `4) Record or field is read-only. ` +\n          `Check the error details for more information.`;\n      } else if (error instanceof AirtableRateLimitError) {\n        enhancedMessage = `${contextInfo}. Rate limit exceeded (${error.status}): ${error.message}. ` +\n          `Please wait before retrying the upload. Consider implementing exponential backoff.`;\n      } else if (error.status === 400) {\n        enhancedMessage = `${contextInfo}. Bad request (${error.status}): ${error.message}. ` +\n          `Common causes: 1) Invalid field name \"${fieldName}\" (try using fieldId like \"fldXXXXXXXXXXXXXX\"), ` +\n          `2) Field is not an attachment field, ` +\n          `3) Request body is malformed (must be JSON with { contentType, file (base64), filename }), ` +\n          `Check the error details for more information.`;\n      } else if (error.status === 413) {\n        enhancedMessage = `${contextInfo}. Payload too large (${error.status}): ${error.message}. ` +\n          `File size (${stats.size} bytes) may exceed Airtable's limits even if under 5MB. ` +\n          `Try compressing the file or using a smaller file.`;\n      } else if (error.status >= 500) {\n        enhancedMessage = `${contextInfo}. Server error (${error.status}): ${error.message}. ` +\n          `This is an Airtable server-side issue. Please retry the upload after a few moments.`;\n      } else {\n        enhancedMessage = `${contextInfo}. HTTP error (${error.status}): ${error.message}`;\n      }\n\n      // Create a new error with enhanced message, preserving all original properties\n      const enhancedError = new AirtableHttpError({\n        status: error.status,\n        statusText: error.statusText,\n        url: error.url,\n        message: enhancedMessage,\n        details: {\n          ...(typeof error.details === \"object\" && error.details !== null ? error.details : {}),\n          uploadContext: {\n            tableName,\n            recordId,\n            fieldName,\n            filePath,\n            filename: finalFilename,\n            fileSize: stats.size,\n            contentType: finalContentType,\n          },\n        },\n      });\n\n      // Preserve the specific error type if it's a subclass\n      if (error instanceof AirtableAuthError) {\n        throw new AirtableAuthError(enhancedError);\n      } else if (error instanceof AirtableNotFoundError) {\n        throw new AirtableNotFoundError(enhancedError);\n      } else if (error instanceof AirtableValidationError) {\n        throw new AirtableValidationError(enhancedError);\n      } else if (error instanceof AirtableRateLimitError) {\n        throw new AirtableRateLimitError(enhancedError);\n      } else {\n        throw enhancedError;\n      }\n    }\n\n    // Enhance network errors with upload-specific context\n    if (error instanceof AirtableNetworkError) {\n      const contextInfo = `Network error during upload of file \"${finalFilename}\" (${stats.size} bytes) ` +\n        `to table \"${tableName}\", record \"${recordId}\", field \"${fieldName}\"`;\n      \n      const enhancedMessage = `${contextInfo}. ${error.message}. ` +\n        `This may be a temporary network issue. Please check your internet connection and try again. ` +\n        `If the problem persists, the file may be too large for your network connection.`;\n\n      throw new AirtableNetworkError({\n        url: error.url,\n        message: enhancedMessage,\n        details: {\n          ...(typeof error.details === \"object\" && error.details !== null ? error.details : {}),\n          uploadContext: {\n            tableName,\n            recordId,\n            fieldName,\n            filePath,\n            filename: finalFilename,\n            fileSize: stats.size,\n            contentType: finalContentType,\n          },\n        },\n      });\n    }\n\n    // Re-throw any other errors as-is\n    throw error;\n  }\n}\n\nexport async function addAttachmentToRecord<TFields extends AirtableFields = AirtableFields>(\n  args: {\n    client: AirtableClient;\n    tableName: string;\n    recordId: string;\n    fieldName: string;\n    attachment?: AirtableAttachment;\n    // Alternative: allow passing attachment properties directly for convenience\n    url?: string;\n    filePath?: string;\n    filename?: string;\n    contentType?: string;\n    size?: number;\n    type?: string;\n  },\n): Promise<import(\"../../core/types/airtable\").AirtableRecord<TFields>> {\n  const { client, tableName, recordId, fieldName, attachment, url, filePath, filename, contentType, size, type } = args;\n\n  // Build attachment object from either the attachment parameter or individual properties\n  // If attachment is provided, use it; otherwise, construct from individual properties\n  const attachmentObj: AirtableAttachment = attachment || {\n    url,\n    filePath,\n    filename,\n    size,\n    type: type || contentType, // Support both 'type' and 'contentType' for convenience\n  };\n\n  // Validate that either url or filePath is provided\n  if (!attachmentObj.url && !attachmentObj.filePath) {\n    throw new Error(\n      \"addAttachmentToRecord: Either 'url' or 'filePath' must be provided (either in attachment object or as direct parameters)\",\n    );\n  }\n\n  // If filePath is provided, use uploadAttachment endpoint for local files\n  if (attachmentObj.filePath) {\n    return uploadLocalFile<TFields>(\n      client,\n      tableName,\n      recordId,\n      fieldName,\n      attachmentObj.filePath,\n      attachmentObj.filename,\n      attachmentObj.type,\n    );\n  }\n\n  // For URLs, use the existing method (GET + PATCH)\n  // Validate that url is provided and is a valid URL\n  if (!attachmentObj.url) {\n    throw new Error(\"addAttachmentToRecord: 'url' is required when 'filePath' is not provided\");\n  }\n\n  // Check if it's a URL (starts with http:// or https://)\n  if (!isUrl(attachmentObj.url)) {\n    throw new Error(\n      `addAttachmentToRecord: Invalid URL format. URL must start with 'http://' or 'https://'. Got: ${attachmentObj.url}`,\n    );\n  }\n\n  // Fetch the current record to get existing attachments\n  const currentRecord = await client.getRecord<TFields>(tableName, recordId);\n\n  // Get existing attachments from the field, or empty array if field is empty/undefined\n  const existingAttachments = (currentRecord.fields[fieldName] as AirtableAttachment[] | undefined) ?? [];\n\n  // Append the new attachment to the existing array\n  const updatedAttachments = [...existingAttachments, attachmentObj];\n\n  // Update the record with the complete attachment array\n  return client.updateRecord<TFields>(tableName, recordId, {\n    [fieldName]: updatedAttachments,\n  } as Partial<TFields>);\n}\n","import type {\n  AirtableFields,\n  AirtableListParams,\n  AirtableRecord,\n} from \"../../core/types/airtable\";\nimport type { AirtableClient } from \"../client/createClient\";\nimport { listAllRecords, type AirtableListAllOptions } from \"../client/pagination\";\n\nexport type TableMapper<TFields extends AirtableFields, TModel> = {\n  /**\n   * Convert a domain model into Airtable fields (for create/update).\n   * Keep this pure (no network).\n   */\n  toFields: (model: Partial<TModel>) => Partial<TFields>;\n\n  /**\n   * Convert an Airtable record into a domain model.\n   * Should validate / normalize where appropriate.\n   */\n  fromRecord: (record: AirtableRecord<TFields>) => TModel;\n};\n\nexport type TableRepo<TFields extends AirtableFields, TModel> = {\n  listPage: (params?: AirtableListParams) => Promise<{ records: TModel[]; offset?: string }>;\n  listAll: (params?: Omit<AirtableListParams, \"offset\">, options?: AirtableListAllOptions) => Promise<TModel[]>;\n  get: (recordId: string) => Promise<TModel>;\n  create: (model: Partial<TModel>) => Promise<TModel>;\n  update: (recordId: string, patch: Partial<TModel>) => Promise<TModel>;\n  delete: (recordId: string) => Promise<{ id: string; deleted: boolean }>;\n};\n\nexport function createTableRepo<TFields extends AirtableFields, TModel>(args: {\n  client: AirtableClient;\n  tableName: string;\n  mapper: TableMapper<TFields, TModel>;\n}): TableRepo<TFields, TModel> {\n  const { client, tableName, mapper } = args;\n\n  return {\n    async listPage(params?: AirtableListParams) {\n      const page = await client.listRecords<TFields>(tableName, params);\n      return {\n        records: page.records.map(mapper.fromRecord),\n        offset: page.offset,\n      };\n    },\n\n    async listAll(params?: Omit<AirtableListParams, \"offset\">, options?: AirtableListAllOptions) {\n      const records = await listAllRecords<TFields>({\n        client,\n        tableName,\n        params,\n        options,\n      });\n      return records.map(mapper.fromRecord);\n    },\n\n    async get(recordId: string) {\n      const record = await client.getRecord<TFields>(tableName, recordId);\n      return mapper.fromRecord(record);\n    },\n\n    async create(model: Partial<TModel>) {\n      const fields = mapper.toFields(model);\n      const record = await client.createRecord<TFields>(tableName, fields);\n      return mapper.fromRecord(record);\n    },\n\n    async update(recordId: string, patch: Partial<TModel>) {\n      const fields = mapper.toFields(patch);\n      const record = await client.updateRecord<TFields>(tableName, recordId, fields);\n      return mapper.fromRecord(record);\n    },\n\n    async delete(recordId: string) {\n      return client.deleteRecord(tableName, recordId);\n    },\n  };\n}\n","import type { AirtableClient } from \"../client/createClient\";\nimport { createTableRepo } from \"./createTableRepo\";\nimport type { Lead } from \"../../core/domain/lead\";\nimport { leadFromRecord, leadToFields, type LeadFields } from \"../../core/mappers/leadMapper\";\n\nexport function createLeadsRepo(args: {\n  client: AirtableClient;\n  tableName?: string;\n}) {\n  return createTableRepo<LeadFields, Lead>({\n    client: args.client,\n    tableName: args.tableName ?? \"Leads\",\n    mapper: {\n      toFields: leadToFields,\n      fromRecord: leadFromRecord,\n    },\n  });\n}\n"],"mappings":";;;;;;AA8IO,IAAM,oBAAN,cAAgC,MAAM;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAET,YAAY,MAA+F;AACzG,UAAM,KAAK,OAAO;AAClB,SAAK,OAAO;AACZ,SAAK,SAAS,KAAK;AACnB,SAAK,aAAa,KAAK;AACvB,SAAK,MAAM,KAAK;AAChB,SAAK,UAAU,KAAK;AAAA,EACtB;AACF;AA8DO,IAAM,oBAAN,cAAgC,kBAAkB;AAAA,EACvD,YAAY,MAAyB;AACnC,UAAM,EAAE,QAAQ,KAAK,QAAQ,YAAY,KAAK,YAAY,KAAK,KAAK,KAAK,SAAS,KAAK,SAAS,SAAS,KAAK,QAAQ,CAAC;AACvH,SAAK,OAAO;AAAA,EACd;AACF;AA8DO,IAAM,yBAAN,cAAqC,kBAAkB;AAAA,EAC5D,YAAY,MAAyB;AACnC,UAAM,EAAE,QAAQ,KAAK,QAAQ,YAAY,KAAK,YAAY,KAAK,KAAK,KAAK,SAAS,KAAK,SAAS,SAAS,KAAK,QAAQ,CAAC;AACvH,SAAK,OAAO;AAAA,EACd;AACF;AA8DO,IAAM,wBAAN,cAAoC,kBAAkB;AAAA,EAC3D,YAAY,MAAyB;AACnC,UAAM,EAAE,QAAQ,KAAK,QAAQ,YAAY,KAAK,YAAY,KAAK,KAAK,KAAK,SAAS,KAAK,SAAS,SAAS,KAAK,QAAQ,CAAC;AACvH,SAAK,OAAO;AAAA,EACd;AACF;AA+DO,IAAM,0BAAN,cAAsC,kBAAkB;AAAA,EAC7D,YAAY,MAAyB;AACnC,UAAM,EAAE,QAAQ,KAAK,QAAQ,YAAY,KAAK,YAAY,KAAK,KAAK,KAAK,SAAS,KAAK,SAAS,SAAS,KAAK,QAAQ,CAAC;AACvH,SAAK,OAAO;AAAA,EACd;AACF;AAsEO,IAAM,uBAAN,cAAmC,kBAAkB;AAAA,EAC1D,YAAY,MAA2D;AACrE,UAAM,EAAE,QAAQ,KAAK,YAAY,iBAAiB,KAAK,KAAK,KAAK,SAAS,KAAK,SAAS,SAAS,KAAK,QAAQ,CAAC;AAC/G,SAAK,OAAO;AAAA,EACd;AACF;AA2DA,SAAS,cAAc,MAAuB;AAC5C,MAAI;AACF,WAAO,KAAK,MAAM,IAAI;AAAA,EACxB,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAgEA,SAAS,sBAAsB,QAAgB,YAAoB,SAA2B;AAE5F,MAAI,WAAW,OAAO,YAAY,UAAU;AAC1C,UAAM,aAAa;AACnB,UAAM,MAAM,YAAY,OAAO;AAC/B,UAAM,MAAM,YAAY,OAAO;AAC/B,QAAI,OAAO,QAAQ,YAAY,OAAO,QAAQ,SAAU,QAAO,GAAG,GAAG,KAAK,GAAG;AAC7E,QAAI,OAAO,QAAQ,SAAU,QAAO;AAAA,EACtC;AACA,SAAO,GAAG,MAAM,IAAI,UAAU,GAAG,KAAK;AACxC;AA+DA,SAAS,gBAAgB,KAA2C;AAClE,MAAI,IAAI,WAAW,OAAO,IAAI,WAAW,IAAK,QAAO,IAAI,kBAAkB,GAAG;AAC9E,MAAI,IAAI,WAAW,IAAK,QAAO,IAAI,sBAAsB,GAAG;AAC5D,MAAI,IAAI,WAAW,IAAK,QAAO,IAAI,wBAAwB,GAAG;AAC9D,MAAI,IAAI,WAAW,IAAK,QAAO,IAAI,uBAAuB,GAAG;AAC7D,SAAO;AACT;AA4GA,eAAsB,gBAA2B,MAK1B;AACrB,QAAM,EAAE,KAAK,QAAQ,QAAQ,KAAK,IAAI;AAEtC,QAAM,aAAa,IAAI,gBAAgB;AACvC,QAAM,UAAU,WAAW,MAAM,WAAW,MAAM,GAAG,OAAO,SAAS;AAErE,MAAI;AACF,UAAM,MAAM,MAAM,MAAM,KAAK;AAAA,MAC3B;AAAA,MACA,QAAQ,WAAW;AAAA,MACnB,SAAS;AAAA,QACP,eAAe,UAAU,OAAO,KAAK;AAAA,QACrC,gBAAgB;AAAA,MAClB;AAAA,MACA,MAAM,SAAS,SAAY,SAAY,KAAK,UAAU,IAAI;AAAA,IAC5D,CAAC;AAED,UAAM,cAAc,IAAI,QAAQ,IAAI,cAAc,KAAK;AACvD,UAAM,UAAU,MAAM,IAAI,KAAK;AAC/B,UAAM,SAAS,YAAY,SAAS,kBAAkB,IAAI,cAAc,OAAO,IAAI;AAEnF,QAAI,CAAC,IAAI,IAAI;AACX,YAAM,UAAU,sBAAsB,IAAI,QAAQ,IAAI,YAAY,MAAM;AACxE,YAAM,UAAU,IAAI,kBAAkB;AAAA,QACpC,QAAQ,IAAI;AAAA,QACZ,YAAY,IAAI;AAAA,QAChB;AAAA,QACA;AAAA,QACA,SAAS;AAAA,MACX,CAAC;AACD,YAAM,gBAAgB,OAAO;AAAA,IAC/B;AAEA,WAAQ,UAAyB;AAAA,EACnC,SAAS,KAAU;AAEjB,QAAI,KAAK,SAAS,cAAc;AAC9B,YAAM,IAAI,kBAAkB;AAAA,QAC1B,QAAQ;AAAA,QACR,YAAY;AAAA,QACZ;AAAA,QACA,SAAS,2BAA2B,OAAO,SAAS;AAAA,MACtD,CAAC;AAAA,IACH;AAGA,QAAI,eAAe,mBAAmB;AACpC,YAAM;AAAA,IACR;AAGA,UAAM,MAAM,OAAO,KAAK,YAAY,WAAW,IAAI,UAAU;AAC7D,UAAM,IAAI,qBAAqB,EAAE,KAAK,SAAS,KAAK,SAAS,IAAI,CAAC;AAAA,EACpE,UAAE;AACA,iBAAa,OAAO;AAAA,EACtB;AACF;;;AC7zBO,IAAM,2BAA2B;AA6DjC,SAAS,aAAa,QAAgB,QAAwB;AACnE,QAAM,UAAU,OAAO,QAAQ,QAAQ,EAAE;AACzC,SAAO,GAAG,OAAO,IAAI,mBAAmB,MAAM,CAAC;AACjD;AA4DO,SAAS,eAAe,WAA2B;AAExD,SAAO,IAAI,mBAAmB,SAAS,CAAC;AAC1C;AA6DO,SAAS,gBAAgB,WAAmB,UAA0B;AAC3E,SAAO,GAAG,eAAe,SAAS,CAAC,IAAI,mBAAmB,QAAQ,CAAC;AACrE;AAoEO,SAAS,eAAe,QAAqC;AAClE,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,IAAI,IAAI,gBAAgB;AAE9B,MAAI,OAAO,KAAM,GAAE,IAAI,QAAQ,OAAO,IAAI;AAC1C,MAAI,OAAO,gBAAiB,GAAE,IAAI,mBAAmB,OAAO,eAAe;AAC3E,MAAI,OAAO,OAAO,eAAe,SAAU,GAAE,IAAI,cAAc,OAAO,OAAO,UAAU,CAAC;AACxF,MAAI,OAAO,OAAO,aAAa,SAAU,GAAE,IAAI,YAAY,OAAO,OAAO,QAAQ,CAAC;AAClF,MAAI,OAAO,OAAQ,GAAE,IAAI,UAAU,OAAO,MAAM;AAEhD,MAAI,OAAO,MAAM,QAAQ;AACvB,WAAO,KAAK,QAAQ,CAAC,GAAG,MAAM;AAC5B,QAAE,IAAI,QAAQ,CAAC,YAAY,EAAE,KAAK;AAClC,UAAI,EAAE,UAAW,GAAE,IAAI,QAAQ,CAAC,gBAAgB,EAAE,SAAS;AAAA,IAC7D,CAAC;AAAA,EACH;AAEA,QAAM,KAAK,EAAE,SAAS;AACtB,SAAO,KAAK,IAAI,EAAE,KAAK;AACzB;;;ACnBO,SAAS,qBACd,QACgB;AAChB,QAAM,SAAS,OAAO,UAAU;AAChC,QAAM,YAAY,OAAO,aAAa;AAEtC,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,2CAA2C;AAC7D,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,4CAA4C;AAE9D,QAAM,UAAU,aAAa,QAAQ,OAAO,MAAM;AAElD,QAAM,YAAmC;AAAA,IACvC,OAAO,OAAO;AAAA,IACd;AAAA,EACF;AAEA,iBAAe,YACb,WACA,QACwC;AACxC,UAAM,MAAM,GAAG,OAAO,GAAG,eAAe,SAAS,CAAC,GAAG,eAAe,MAAM,CAAC;AAC3E,WAAO,gBAA+C;AAAA,MACpD;AAAA,MACA,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL,QAAQ,OAAO;AAAA,IACf;AAAA,IAEA;AAAA,IACA,UAAU;AAAA,IAEV,MAAM,UACJ,WACA,UACkC;AAClC,YAAM,MAAM,GAAG,OAAO,GAAG,gBAAgB,WAAW,QAAQ,CAAC;AAC7D,aAAO,gBAAyC;AAAA,QAC9C;AAAA,QACA,QAAQ;AAAA,QACR,QAAQ;AAAA,MACV,CAAC;AAAA,IACH;AAAA,IAEA,MAAM,aACJ,WACA,QACkC;AAClC,YAAM,MAAM,GAAG,OAAO,GAAG,eAAe,SAAS,CAAC;AAClD,aAAO,gBAAyC;AAAA,QAC9C;AAAA,QACA,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,MAAM,EAAE,OAAO;AAAA,MACjB,CAAC;AAAA,IACH;AAAA,IAEA,MAAM,aACJ,WACA,UACA,QACkC;AAClC,YAAM,MAAM,GAAG,OAAO,GAAG,gBAAgB,WAAW,QAAQ,CAAC;AAC7D,aAAO,gBAAyC;AAAA,QAC9C;AAAA,QACA,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,MAAM,EAAE,OAAO;AAAA,MACjB,CAAC;AAAA,IACH;AAAA,IAEA,MAAM,aACJ,WACA,UAC2C;AAC3C,YAAM,MAAM,GAAG,OAAO,GAAG,gBAAgB,WAAW,QAAQ,CAAC;AAC7D,aAAO,gBAAkD;AAAA,QACvD;AAAA,QACA,QAAQ;AAAA,QACR,QAAQ;AAAA,MACV,CAAC;AAAA,IACH;AAAA,IAEA,MAAM,SACJ,KACA,QACA,MACoB;AACpB,aAAO,gBAA2B;AAAA,QAChC;AAAA,QACA;AAAA,QACA,QAAQ;AAAA,QACR;AAAA,MACF,CAAC;AAAA,IACH;AAAA,IAEA,MAAM,kBACJ,KACA,UACoB;AACpB,YAAM,aAAa,IAAI,gBAAgB;AACvC,YAAM,UAAU,WAAW,MAAM,WAAW,MAAM,GAAG,UAAU,SAAS;AAExE,UAAI;AACF,cAAM,MAAM,MAAM,MAAM,KAAK;AAAA,UAC3B,QAAQ;AAAA,UACR,QAAQ,WAAW;AAAA,UACnB,SAAS;AAAA,YACP,eAAe,UAAU,UAAU,KAAK;AAAA;AAAA,UAE1C;AAAA,UACA,MAAM;AAAA,QACR,CAAC;AAED,cAAM,cAAc,IAAI,QAAQ,IAAI,cAAc,KAAK;AACvD,cAAM,UAAU,MAAM,IAAI,KAAK;AAC/B,cAAM,SAAS,YAAY,SAAS,kBAAkB,IACjD,KAAK,MAAM,OAAO,IACnB;AAEJ,YAAI,CAAC,IAAI,IAAI;AACX,gBAAM,UACJ,OAAO,WAAW,YAClB,WAAW,QACX,WAAW,UACX,OAAQ,OAAe,UAAU,YAChC,OAAe,OAAO,UAClB,OAAe,MAAM,UACtB,8BAA8B,IAAI,MAAM;AAC9C,gBAAM,UAAU,IAAI,kBAAkB;AAAA,YACpC,QAAQ,IAAI;AAAA,YACZ,YAAY,IAAI;AAAA,YAChB;AAAA,YACA;AAAA,YACA,SAAS;AAAA,UACX,CAAC;AACD,gBAAM;AAAA,QACR;AAEA,eAAQ,UAAyB;AAAA,MACnC,SAAS,KAAU;AAEjB,YAAI,KAAK,SAAS,cAAc;AAC9B,gBAAM,IAAI,kBAAkB;AAAA,YAC1B,QAAQ;AAAA,YACR,YAAY;AAAA,YACZ;AAAA,YACA,SAAS,2BAA2B,UAAU,SAAS;AAAA,UACzD,CAAC;AAAA,QACH;AAGA,YAAI,eAAe,mBAAmB;AACpC,gBAAM;AAAA,QACR;AAGA,cAAM,MAAM,OAAO,KAAK,YAAY,WAAW,IAAI,UAAU;AAC7D,cAAM,IAAI,qBAAqB,EAAE,KAAK,SAAS,KAAK,SAAS,IAAI,CAAC;AAAA,MACpE,UAAE;AACA,qBAAa,OAAO;AAAA,MACtB;AAAA,IACF;AAAA,EACF;AACF;;;ACrUA,eAAsB,eAEpB,MAK0C;AAC1C,QAAM,EAAE,QAAQ,WAAW,QAAQ,QAAQ,IAAI;AAE/C,QAAM,kBAAkB,SAAS,mBAAmB;AAEpD,QAAM,MAAsC,CAAC;AAC7C,MAAI,SAA6B;AAEjC,SAAO,MAAM;AACX,UAAM,OAAsC,MAAM,OAAO,YAAqB,WAAW;AAAA,MACvF,GAAI,UAAU,CAAC;AAAA,MACf;AAAA,IACF,CAAC;AAED,QAAI,KAAK,GAAG,KAAK,OAAO;AAExB,QAAI,IAAI,SAAS,iBAAiB;AAChC,YAAM,IAAI;AAAA,QACR,6CAA6C,eAAe;AAAA,MAE9D;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,OAAQ;AAClB,aAAS,KAAK;AAAA,EAChB;AAEA,SAAO;AACT;;;ACxLA,SAAS,YAAY,UAAU;AAC/B,SAAS,eAAe;AAgExB,IAAM,gBAAgB,IAAI,OAAO;AAKjC,IAAM,aAAqC;AAAA,EACzC,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,SAAS;AACX;AAKA,SAAS,yBAAyB,UAA0B;AAC1D,QAAM,MAAM,QAAQ,QAAQ,EAAE,YAAY;AAC1C,SAAO,WAAW,GAAG,KAAK;AAC5B;AAKA,eAAe,iBAAiB,UAA6D;AAC3F,MAAI;AACF,UAAM,SAAS,MAAM,GAAG,SAAS,QAAQ;AACzC,UAAM,OAAO,OAAO;AAEpB,QAAI,OAAO,eAAe;AACxB,YAAM,IAAI;AAAA,QACR,cAAc,IAAI,2CAA2C,aAAa;AAAA,MAC5E;AAAA,IACF;AAEA,UAAM,SAAS,OAAO,SAAS,QAAQ;AACvC,WAAO,EAAE,QAAQ,KAAK;AAAA,EACxB,SAAS,OAAY;AACnB,QAAI,MAAM,SAAS,UAAU;AAC3B,YAAM,IAAI,MAAM,mBAAmB,QAAQ,EAAE;AAAA,IAC/C;AACA,UAAM;AAAA,EACR;AACF;AAKA,SAAS,oBAAoB,UAA0B;AACrD,QAAM,QAAQ,SAAS,MAAM,OAAO;AACpC,SAAO,MAAM,MAAM,SAAS,CAAC,KAAK;AACpC;AAKA,SAAS,MAAM,KAAsB;AACnC,SAAO,IAAI,WAAW,SAAS,KAAK,IAAI,WAAW,UAAU;AAC/D;AAeA,eAAe,gBACb,QACA,WACA,UACA,WACA,UACA,UACA,aACsE;AAEtE,MAAI,CAAC,aAAa,OAAO,cAAc,YAAY,UAAU,KAAK,EAAE,WAAW,GAAG;AAChF,UAAM,IAAI;AAAA,MACR,uEAAuE,KAAK,UAAU,SAAS,CAAC;AAAA,IAClG;AAAA,EACF;AACA,MAAI,CAAC,YAAY,OAAO,aAAa,YAAY,SAAS,KAAK,EAAE,WAAW,GAAG;AAC7E,UAAM,IAAI;AAAA,MACR,sEAAsE,KAAK,UAAU,QAAQ,CAAC;AAAA,IAChG;AAAA,EACF;AACA,MAAI,CAAC,aAAa,OAAO,cAAc,YAAY,UAAU,KAAK,EAAE,WAAW,GAAG;AAChF,UAAM,IAAI;AAAA,MACR,uEAAuE,KAAK,UAAU,SAAS,CAAC;AAAA,IAClG;AAAA,EACF;AACA,MAAI,CAAC,YAAY,OAAO,aAAa,YAAY,SAAS,KAAK,EAAE,WAAW,GAAG;AAC7E,UAAM,IAAI;AAAA,MACR,sEAAsE,KAAK,UAAU,QAAQ,CAAC;AAAA,IAChG;AAAA,EACF;AAGA,QAAM,gBAAgB,YAAY,oBAAoB,QAAQ;AAC9D,MAAI,CAAC,iBAAiB,cAAc,KAAK,EAAE,WAAW,GAAG;AACvD,UAAM,IAAI;AAAA,MACR,6DAA6D,QAAQ;AAAA,IACvE;AAAA,EACF;AAGA,QAAM,mBAAmB,eAAe,yBAAyB,QAAQ;AAGzE,MAAI;AACJ,MAAI;AACF,YAAQ,MAAM,GAAG,KAAK,QAAQ;AAAA,EAChC,SAAS,OAAY;AAEnB,QAAI,MAAM,SAAS,UAAU;AAC3B,YAAM,IAAI;AAAA,QACR,4CAA4C,QAAQ;AAAA,MACtD;AAAA,IACF;AACA,QAAI,MAAM,SAAS,UAAU;AAC3B,YAAM,IAAI;AAAA,QACR,sDAAsD,QAAQ;AAAA,MAChE;AAAA,IACF;AACA,QAAI,MAAM,SAAS,UAAU;AAC3B,YAAM,IAAI;AAAA,QACR,0BAA0B,QAAQ;AAAA,MACpC;AAAA,IACF;AACA,QAAI,MAAM,SAAS,YAAY,MAAM,SAAS,UAAU;AACtD,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,IAAI;AAAA,MACR,2CAA2C,QAAQ,MAAM,MAAM,WAAW,MAAM,QAAQ,eAAe;AAAA,IACzG;AAAA,EACF;AAGA,MAAI,CAAC,MAAM,OAAO,GAAG;AACnB,UAAM,IAAI;AAAA,MACR,0BAA0B,QAAQ,yCAAyC,MAAM,YAAY,CAAC,qBAAqB,MAAM,eAAe,CAAC;AAAA,IAC3I;AAAA,EACF;AAGA,MAAI,MAAM,OAAO,eAAe;AAC9B,UAAM,UAAU,MAAM,QAAQ,OAAO,OAAO,QAAQ,CAAC;AACrD,UAAM,SAAS,iBAAiB,OAAO,OAAO,QAAQ,CAAC;AACvD,UAAM,IAAI;AAAA,MACR,+BAA+B,MAAM,IAAI,WAAW,MAAM,wCAAwC,aAAa,WAAW,KAAK;AAAA,IAEjI;AAAA,EACF;AAGA,MAAI,MAAM,SAAS,GAAG;AACpB,UAAM,IAAI;AAAA,MACR,0BAA0B,QAAQ;AAAA,IACpC;AAAA,EACF;AAOA,MAAI;AACJ,MAAI;AACF,UAAM,gBAAgB,OAAO,OAAO,QAAQ,oBAAoB,sBAAsB,EAAE,QAAQ,QAAQ,EAAE;AAC1G,UAAM,gBAAgB,mBAAmB,OAAO,MAAM;AACtD,UAAM,kBAAkB,mBAAmB,QAAQ;AACnD,UAAM,mBAAmB,mBAAmB,SAAS;AACrD,gBAAY,GAAG,aAAa,IAAI,aAAa,IAAI,eAAe,IAAI,gBAAgB;AAAA,EACtF,SAAS,OAAY;AACnB,UAAM,IAAI;AAAA,MACR,gDAAgD,MAAM,WAAW,eAAe,cAClE,OAAO,MAAM,iBAAiB,QAAQ,kBAAkB,SAAS;AAAA,IACjF;AAAA,EACF;AAGA,MAAI;AACJ,MAAI;AAEF,UAAM,MAAM,MAAM,iBAAiB,QAAQ;AAC3C,aAAS,IAAI;AAAA,EACf,SAAS,OAAY;AAEnB,QAAI,MAAM,SAAS,UAAU;AAC3B,YAAM,IAAI;AAAA,QACR,4CAA4C,QAAQ;AAAA,MACtD;AAAA,IACF;AACA,QAAI,MAAM,SAAS,UAAU;AAC3B,YAAM,IAAI;AAAA,QACR,oDAAoD,QAAQ;AAAA,MAC9D;AAAA,IACF;AACA,QAAI,MAAM,SAAS,UAAU;AAC3B,YAAM,IAAI;AAAA,QACR,iCAAiC,QAAQ;AAAA,MAC3C;AAAA,IACF;AACA,QAAI,MAAM,SAAS,YAAY,MAAM,SAAS,UAAU;AACtD,YAAM,IAAI;AAAA,QACR,uDAAuD,QAAQ;AAAA,MACjE;AAAA,IACF;AAEA,UAAM,IAAI;AAAA,MACR,yCAAyC,QAAQ,MAAM,MAAM,WAAW,MAAM,QAAQ,eAAe;AAAA,IACvG;AAAA,EACF;AAGA,MAAI,CAAC,UAAU,OAAO,WAAW,GAAG;AAClC,UAAM,IAAI;AAAA,MACR,0BAA0B,QAAQ;AAAA,IACpC;AAAA,EACF;AAKA,MAAI;AACF,UAAM,WAAW,MAAM,OAAO;AAAA,MAC5B;AAAA,MACA;AAAA,MACA;AAAA,QACE,aAAa;AAAA,QACb,MAAM;AAAA,QACN,UAAU;AAAA,MACZ;AAAA,IACF;AACA,WAAO;AAAA,EACT,SAAS,OAAY;AAEnB,QAAI,iBAAiB,mBAAmB;AAEtC,YAAM,cAAc,2BAA2B,aAAa,MAAM,MAAM,IAAI,WAAW,gBAAgB,eACxF,SAAS,cAAc,QAAQ,aAAa,SAAS;AAEpE,UAAI;AAGJ,UAAI,iBAAiB,mBAAmB;AACtC,0BAAkB,GAAG,WAAW,4BAA4B,MAAM,MAAM,MAAM,MAAM,OAAO;AAAA,MAE7F,WAAW,iBAAiB,uBAAuB;AACjD,0BAAkB,GAAG,WAAW,yBAAyB,MAAM,MAAM,MAAM,MAAM,OAAO,yCAC/C,OAAO,MAAM,mCAC/B,QAAQ,2BACZ,SAAS,2BACT,SAAS;AAAA,MAE9B,WAAW,iBAAiB,yBAAyB;AACnD,0BAAkB,GAAG,WAAW,wBAAwB,MAAM,MAAM,MAAM,MAAM,OAAO,8BACzD,SAAS;AAAA,MAKzC,WAAW,iBAAiB,wBAAwB;AAClD,0BAAkB,GAAG,WAAW,0BAA0B,MAAM,MAAM,MAAM,MAAM,OAAO;AAAA,MAE3F,WAAW,MAAM,WAAW,KAAK;AAC/B,0BAAkB,GAAG,WAAW,kBAAkB,MAAM,MAAM,MAAM,MAAM,OAAO,2CACtC,SAAS;AAAA,MAItD,WAAW,MAAM,WAAW,KAAK;AAC/B,0BAAkB,GAAG,WAAW,wBAAwB,MAAM,MAAM,MAAM,MAAM,OAAO,gBACvE,MAAM,IAAI;AAAA,MAE5B,WAAW,MAAM,UAAU,KAAK;AAC9B,0BAAkB,GAAG,WAAW,mBAAmB,MAAM,MAAM,MAAM,MAAM,OAAO;AAAA,MAEpF,OAAO;AACL,0BAAkB,GAAG,WAAW,iBAAiB,MAAM,MAAM,MAAM,MAAM,OAAO;AAAA,MAClF;AAGA,YAAM,gBAAgB,IAAI,kBAAkB;AAAA,QAC1C,QAAQ,MAAM;AAAA,QACd,YAAY,MAAM;AAAA,QAClB,KAAK,MAAM;AAAA,QACX,SAAS;AAAA,QACT,SAAS;AAAA,UACP,GAAI,OAAO,MAAM,YAAY,YAAY,MAAM,YAAY,OAAO,MAAM,UAAU,CAAC;AAAA,UACnF,eAAe;AAAA,YACb;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,UAAU;AAAA,YACV,UAAU,MAAM;AAAA,YAChB,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF,CAAC;AAGD,UAAI,iBAAiB,mBAAmB;AACtC,cAAM,IAAI,kBAAkB,aAAa;AAAA,MAC3C,WAAW,iBAAiB,uBAAuB;AACjD,cAAM,IAAI,sBAAsB,aAAa;AAAA,MAC/C,WAAW,iBAAiB,yBAAyB;AACnD,cAAM,IAAI,wBAAwB,aAAa;AAAA,MACjD,WAAW,iBAAiB,wBAAwB;AAClD,cAAM,IAAI,uBAAuB,aAAa;AAAA,MAChD,OAAO;AACL,cAAM;AAAA,MACR;AAAA,IACF;AAGA,QAAI,iBAAiB,sBAAsB;AACzC,YAAM,cAAc,wCAAwC,aAAa,MAAM,MAAM,IAAI,qBAC1E,SAAS,cAAc,QAAQ,aAAa,SAAS;AAEpE,YAAM,kBAAkB,GAAG,WAAW,KAAK,MAAM,OAAO;AAIxD,YAAM,IAAI,qBAAqB;AAAA,QAC7B,KAAK,MAAM;AAAA,QACX,SAAS;AAAA,QACT,SAAS;AAAA,UACP,GAAI,OAAO,MAAM,YAAY,YAAY,MAAM,YAAY,OAAO,MAAM,UAAU,CAAC;AAAA,UACnF,eAAe;AAAA,YACb;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,UAAU;AAAA,YACV,UAAU,MAAM;AAAA,YAChB,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAGA,UAAM;AAAA,EACR;AACF;AAEA,eAAsB,sBACpB,MAcsE;AACtE,QAAM,EAAE,QAAQ,WAAW,UAAU,WAAW,YAAY,KAAK,UAAU,UAAU,aAAa,MAAM,KAAK,IAAI;AAIjH,QAAM,gBAAoC,cAAc;AAAA,IACtD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM,QAAQ;AAAA;AAAA,EAChB;AAGA,MAAI,CAAC,cAAc,OAAO,CAAC,cAAc,UAAU;AACjD,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAGA,MAAI,cAAc,UAAU;AAC1B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd,cAAc;AAAA,MACd,cAAc;AAAA,IAChB;AAAA,EACF;AAIA,MAAI,CAAC,cAAc,KAAK;AACtB,UAAM,IAAI,MAAM,0EAA0E;AAAA,EAC5F;AAGA,MAAI,CAAC,MAAM,cAAc,GAAG,GAAG;AAC7B,UAAM,IAAI;AAAA,MACR,gGAAgG,cAAc,GAAG;AAAA,IACnH;AAAA,EACF;AAGA,QAAM,gBAAgB,MAAM,OAAO,UAAmB,WAAW,QAAQ;AAGzE,QAAM,sBAAuB,cAAc,OAAO,SAAS,KAA0C,CAAC;AAGtG,QAAM,qBAAqB,CAAC,GAAG,qBAAqB,aAAa;AAGjE,SAAO,OAAO,aAAsB,WAAW,UAAU;AAAA,IACvD,CAAC,SAAS,GAAG;AAAA,EACf,CAAqB;AACvB;;;ACjeO,SAAS,gBAAwD,MAIzC;AAC7B,QAAM,EAAE,QAAQ,WAAW,OAAO,IAAI;AAEtC,SAAO;AAAA,IACL,MAAM,SAAS,QAA6B;AAC1C,YAAM,OAAO,MAAM,OAAO,YAAqB,WAAW,MAAM;AAChE,aAAO;AAAA,QACL,SAAS,KAAK,QAAQ,IAAI,OAAO,UAAU;AAAA,QAC3C,QAAQ,KAAK;AAAA,MACf;AAAA,IACF;AAAA,IAEA,MAAM,QAAQ,QAA6C,SAAkC;AAC3F,YAAM,UAAU,MAAM,eAAwB;AAAA,QAC5C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AACD,aAAO,QAAQ,IAAI,OAAO,UAAU;AAAA,IACtC;AAAA,IAEA,MAAM,IAAI,UAAkB;AAC1B,YAAM,SAAS,MAAM,OAAO,UAAmB,WAAW,QAAQ;AAClE,aAAO,OAAO,WAAW,MAAM;AAAA,IACjC;AAAA,IAEA,MAAM,OAAO,OAAwB;AACnC,YAAM,SAAS,OAAO,SAAS,KAAK;AACpC,YAAM,SAAS,MAAM,OAAO,aAAsB,WAAW,MAAM;AACnE,aAAO,OAAO,WAAW,MAAM;AAAA,IACjC;AAAA,IAEA,MAAM,OAAO,UAAkB,OAAwB;AACrD,YAAM,SAAS,OAAO,SAAS,KAAK;AACpC,YAAM,SAAS,MAAM,OAAO,aAAsB,WAAW,UAAU,MAAM;AAC7E,aAAO,OAAO,WAAW,MAAM;AAAA,IACjC;AAAA,IAEA,MAAM,OAAO,UAAkB;AAC7B,aAAO,OAAO,aAAa,WAAW,QAAQ;AAAA,IAChD;AAAA,EACF;AACF;;;ACzEO,SAAS,gBAAgB,MAG7B;AACD,SAAO,gBAAkC;AAAA,IACvC,QAAQ,KAAK;AAAA,IACb,WAAW,KAAK,aAAa;AAAA,IAC7B,QAAQ;AAAA,MACN,UAAU;AAAA,MACV,YAAY;AAAA,IACd;AAAA,EACF,CAAC;AACH;","names":[]}