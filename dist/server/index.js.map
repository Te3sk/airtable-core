{"version":3,"sources":["../../src/server/client/request.ts","../../src/server/client/endpoints.ts","../../src/server/client/createClient.ts","../../src/server/client/pagination.ts","../../src/server/repos/createTableRepo.ts","../../src/server/repos/leadsRepo.ts"],"sourcesContent":["export type AirtableRequestConfig = {\n  token: string;\n  timeoutMs: number;\n};\n\nexport class AirtableHttpError extends Error {\n  readonly status: number;\n  readonly statusText: string;\n  readonly url: string;\n  readonly details?: unknown;\n\n  constructor(args: { status: number; statusText: string; url: string; message: string; details?: unknown }) {\n    super(args.message);\n    this.name = \"AirtableHttpError\";\n    this.status = args.status;\n    this.statusText = args.statusText;\n    this.url = args.url;\n    this.details = args.details;\n  }\n}\n\n/** Optional specific errors (DX) */\nexport class AirtableAuthError extends AirtableHttpError {\n  constructor(base: AirtableHttpError) {\n    super({ status: base.status, statusText: base.statusText, url: base.url, message: base.message, details: base.details });\n    this.name = \"AirtableAuthError\";\n  }\n}\n\nexport class AirtableRateLimitError extends AirtableHttpError {\n  constructor(base: AirtableHttpError) {\n    super({ status: base.status, statusText: base.statusText, url: base.url, message: base.message, details: base.details });\n    this.name = \"AirtableRateLimitError\";\n  }\n}\n\nexport class AirtableNotFoundError extends AirtableHttpError {\n  constructor(base: AirtableHttpError) {\n    super({ status: base.status, statusText: base.statusText, url: base.url, message: base.message, details: base.details });\n    this.name = \"AirtableNotFoundError\";\n  }\n}\n\nexport class AirtableValidationError extends AirtableHttpError {\n  constructor(base: AirtableHttpError) {\n    super({ status: base.status, statusText: base.statusText, url: base.url, message: base.message, details: base.details });\n    this.name = \"AirtableValidationError\";\n  }\n}\n\n/**\n * Represents network/transport failures (DNS, connection reset, etc.).\n * We keep it as a normalized AirtableHttpError with a synthetic status.\n */\nexport class AirtableNetworkError extends AirtableHttpError {\n  constructor(args: { url: string; message: string; details?: unknown }) {\n    super({ status: 503, statusText: \"Network Error\", url: args.url, message: args.message, details: args.details });\n    this.name = \"AirtableNetworkError\";\n  }\n}\n\nfunction safeJsonParse(text: string): unknown {\n  try {\n    return JSON.parse(text);\n  } catch {\n    return undefined;\n  }\n}\n\nfunction normalizeErrorMessage(status: number, statusText: string, details?: unknown): string {\n  // Airtable often returns: { error: { type, message } }\n  if (details && typeof details === \"object\") {\n    const anyDetails = details as any;\n    const msg = anyDetails?.error?.message;\n    const typ = anyDetails?.error?.type;\n    if (typeof msg === \"string\" && typeof typ === \"string\") return `${typ}: ${msg}`;\n    if (typeof msg === \"string\") return msg;\n  }\n  return `${status} ${statusText}`.trim();\n}\n\nfunction toSpecificError(err: AirtableHttpError): AirtableHttpError {\n  if (err.status === 401 || err.status === 403) return new AirtableAuthError(err);\n  if (err.status === 404) return new AirtableNotFoundError(err);\n  if (err.status === 422) return new AirtableValidationError(err);\n  if (err.status === 429) return new AirtableRateLimitError(err);\n  return err;\n}\n\nexport async function airtableRequest<TResponse>(args: {\n  url: string;\n  method: \"GET\" | \"POST\" | \"PATCH\" | \"DELETE\";\n  config: AirtableRequestConfig;\n  body?: unknown;\n}): Promise<TResponse> {\n  const { url, method, config, body } = args;\n\n  const controller = new AbortController();\n  const timeout = setTimeout(() => controller.abort(), config.timeoutMs);\n\n  try {\n    const res = await fetch(url, {\n      method,\n      signal: controller.signal,\n      headers: {\n        Authorization: `Bearer ${config.token}`,\n        \"Content-Type\": \"application/json\",\n      },\n      body: body === undefined ? undefined : JSON.stringify(body),\n    });\n\n    const contentType = res.headers.get(\"content-type\") ?? \"\";\n    const rawText = await res.text();\n    const parsed = contentType.includes(\"application/json\") ? safeJsonParse(rawText) : rawText;\n\n    if (!res.ok) {\n      const message = normalizeErrorMessage(res.status, res.statusText, parsed);\n      const baseErr = new AirtableHttpError({\n        status: res.status,\n        statusText: res.statusText,\n        url,\n        message,\n        details: parsed,\n      });\n      throw toSpecificError(baseErr);\n    }\n\n    return (parsed as TResponse) ?? (rawText as unknown as TResponse);\n  } catch (err: any) {\n    // Timeout / Abort normalization\n    if (err?.name === \"AbortError\") {\n      throw new AirtableHttpError({\n        status: 408,\n        statusText: \"Request Timeout\",\n        url,\n        message: `Request timed out after ${config.timeoutMs}ms`,\n      });\n    }\n\n    // If it's already normalized, keep it\n    if (err instanceof AirtableHttpError) {\n      throw err;\n    }\n\n    // Normalize fetch/network errors (TypeError in many runtimes)\n    const msg = typeof err?.message === \"string\" ? err.message : \"Network request failed\";\n    throw new AirtableNetworkError({ url, message: msg, details: err });\n  } finally {\n    clearTimeout(timeout);\n  }\n}\n","import type { AirtableListParams } from \"../../core/types/airtable\";\n\n/**\n * @name DEFAULT_AIRTABLE_API_URL\n * @kind Module\n * @summary Default base URL constant for Airtable REST API v0 endpoint.\n *\n * @description\n * Constant string representing the default base URL for Airtable REST API v0.\n * Used as fallback when apiUrl is not provided in AirtableClientConfig.\n * Points to the official Airtable API endpoint for version 0.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not specified\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - constant value\n * @latency Not applicable\n * @memory Not applicable\n * @rateLimit Not applicable\n * @notes Not applicable\n *\n * @security\n * @inputSanitization Not applicable\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All environments\n * @notSupported None\n *\n * @example\n * // Basic usage\n * const apiUrl = config.apiUrl ?? DEFAULT_AIRTABLE_API_URL;\n *\n * @remarks\n * Value: \"https://api.airtable.com/v0\". Can be overridden in client configuration for custom endpoints or testing.\n *\n * @see AirtableClientConfig\n */\nexport const DEFAULT_AIRTABLE_API_URL = \"https://api.airtable.com/v0\";\n\n/**\n * @name buildBaseUrl\n * @kind Function\n * @summary Constructs the base URL for Airtable API requests by combining API URL with base ID.\n *\n * @description\n * Utility function that builds the base URL for Airtable API requests.\n * Removes trailing slashes from apiUrl, then appends the URL-encoded baseId.\n * Result is used as the base path for all table and record endpoint URLs.\n * Ensures proper URL formatting and encoding for safe HTTP requests.\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable - pure string manipulation\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - simple string operations\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates single string result\n * @rateLimit Not applicable\n * @notes Lightweight string manipulation function.\n *\n * @security\n * @inputSanitization baseId is URL-encoded using encodeURIComponent to prevent injection\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {string} apiUrl - Base API URL (e.g., \"https://api.airtable.com/v0\"). Trailing slashes are removed.\n * @param {string} baseId - Airtable base identifier. Will be URL-encoded in the result.\n *\n * @returns {string} Combined URL string: \"{trimmedApiUrl}/{encodedBaseId}\".\n *\n * @example\n * // Basic usage\n * const baseUrl = buildBaseUrl(\"https://api.airtable.com/v0\", \"app123abc\");\n * // Returns: \"https://api.airtable.com/v0/app123abc\"\n *\n * @example\n * // Handles trailing slashes\n * const baseUrl = buildBaseUrl(\"https://api.airtable.com/v0/\", \"app123abc\");\n * // Returns: \"https://api.airtable.com/v0/app123abc\"\n *\n * @remarks\n * The baseId is URL-encoded to handle special characters safely. Trailing slashes in apiUrl are normalized.\n *\n * @see buildTablePath\n * @see buildRecordPath\n */\nexport function buildBaseUrl(apiUrl: string, baseId: string): string {\n  const trimmed = apiUrl.replace(/\\/+$/, \"\");\n  return `${trimmed}/${encodeURIComponent(baseId)}`;\n}\n\n/**\n * @name buildTablePath\n * @kind Function\n * @summary Constructs the URL path segment for a table endpoint by encoding the table name.\n *\n * @description\n * Utility function that builds the URL path segment for table-level operations.\n * Takes a table name and returns a path string with URL-encoded table name.\n * Used to construct endpoints for list and create operations on tables.\n * Table name is URL-encoded for safety, even though Airtable may accept raw names.\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable - pure string manipulation\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - simple string operations\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates single string result\n * @rateLimit Not applicable\n * @notes Lightweight string manipulation function.\n *\n * @security\n * @inputSanitization tableName is URL-encoded using encodeURIComponent to prevent injection\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {string} tableName - Name of the Airtable table. Will be URL-encoded in the result.\n *\n * @returns {string} Path string: \"/{encodedTableName}\".\n *\n * @example\n * // Basic usage\n * const path = buildTablePath(\"Tasks\");\n * // Returns: \"/Tasks\"\n *\n * @example\n * // Handles special characters\n * const path = buildTablePath(\"My Table\");\n * // Returns: \"/My%20Table\"\n *\n * @remarks\n * Table name is URL-encoded for safety. Result is a path segment, not a full URL. Combine with baseUrl for complete endpoint.\n *\n * @see buildBaseUrl\n * @see buildRecordPath\n */\nexport function buildTablePath(tableName: string): string {\n  // Airtable expects the raw table name in the path; we still encode it for safety.\n  return `/${encodeURIComponent(tableName)}`;\n}\n\n/**\n * @name buildRecordPath\n * @kind Function\n * @summary Constructs the URL path segment for a record endpoint by combining table name and record ID.\n *\n * @description\n * Utility function that builds the URL path segment for record-level operations (get, update, delete).\n * Combines table path with URL-encoded record ID to create the full record endpoint path.\n * Used to construct endpoints for operations on specific records within a table.\n * Both table name and record ID are URL-encoded for safety.\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable - pure string manipulation\n *\n * @dependencies\n * @requires buildTablePath Function to build table path segment\n *\n * @performance\n * @complexity O(1) - simple string operations\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates single string result\n * @rateLimit Not applicable\n * @notes Lightweight string manipulation function.\n *\n * @security\n * @inputSanitization Both tableName and recordId are URL-encoded using encodeURIComponent to prevent injection\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments\n * @notSupported None\n *\n * @param {string} tableName - Name of the Airtable table. Will be URL-encoded.\n * @param {string} recordId - Airtable record identifier. Will be URL-encoded in the result.\n *\n * @returns {string} Path string: \"/{encodedTableName}/{encodedRecordId}\".\n *\n * @example\n * // Basic usage\n * const path = buildRecordPath(\"Tasks\", \"rec123abc\");\n * // Returns: \"/Tasks/rec123abc\"\n *\n * @example\n * // Used in client methods\n * const url = `${baseUrl}${buildRecordPath(\"Users\", recordId)}`;\n *\n * @remarks\n * Both parameters are URL-encoded for safety. Result is a path segment, not a full URL. Combine with baseUrl for complete endpoint.\n *\n * @see buildBaseUrl\n * @see buildTablePath\n */\nexport function buildRecordPath(tableName: string, recordId: string): string {\n  return `${buildTablePath(tableName)}/${encodeURIComponent(recordId)}`;\n}\n\n/**\n * @name buildListQuery\n * @kind Function\n * @summary Constructs URL query string from AirtableListParams for list endpoint requests.\n *\n * @description\n * Utility function that converts AirtableListParams object into a URL query string.\n * Handles all supported list parameters: view, filterByFormula, maxRecords, pageSize, offset, and sort.\n * For sort parameters, builds array-style query params (sort[0][field], sort[0][direction], etc.).\n * Returns empty string if no params provided, or query string prefixed with \"?\" if params exist.\n * Used to append query parameters to list endpoint URLs.\n *\n * @category Utility\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not applicable - pure string manipulation\n *\n * @dependencies\n * @requires ../../core/types/airtable AirtableListParams type definition\n *\n * @performance\n * @complexity O(n) where n is number of sort items - iterates through sort array\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates single string result\n * @rateLimit Not applicable\n * @notes Lightweight function. Complexity is linear with number of sort parameters.\n *\n * @security\n * @inputSanitization All values are added to URLSearchParams which handles encoding automatically\n * @secretsHandling Not applicable\n * @pii filterByFormula may contain field references that could expose PII in query string\n *\n * @compatibility\n * @supported All JavaScript/TypeScript environments with URLSearchParams\n * @notSupported None\n *\n * @param {AirtableListParams} [params] - Optional query parameters object. If omitted, returns empty string.\n *\n * @returns {string} Empty string if no params, or query string prefixed with \"?\" (e.g., \"?view=Active&maxRecords=50\").\n *\n * @example\n * // Basic usage\n * const query = buildListQuery({ view: \"Active\", maxRecords: 50 });\n * // Returns: \"?view=Active&maxRecords=50\"\n *\n * @example\n * // Advanced usage with sorting\n * const query = buildListQuery({\n *   filterByFormula: \"{Status}='Open'\",\n *   sort: [\n *     { field: \"Created\", direction: \"desc\" },\n *     { field: \"Priority\", direction: \"asc\" }\n *   ]\n * });\n * // Returns: \"?filterByFormula={Status}='Open'&sort[0][field]=Created&sort[0][direction]=desc&sort[1][field]=Priority&sort[1][direction]=asc\"\n *\n * @remarks\n * URLSearchParams automatically handles encoding of special characters. Sort parameters use array notation for multi-level sorting.\n *\n * @see AirtableListParams\n * @see buildTablePath\n */\nexport function buildListQuery(params?: AirtableListParams): string {\n  if (!params) return \"\";\n\n  const q = new URLSearchParams();\n\n  if (params.view) q.set(\"view\", params.view);\n  if (params.filterByFormula) q.set(\"filterByFormula\", params.filterByFormula);\n  if (typeof params.maxRecords === \"number\") q.set(\"maxRecords\", String(params.maxRecords));\n  if (typeof params.pageSize === \"number\") q.set(\"pageSize\", String(params.pageSize));\n  if (params.offset) q.set(\"offset\", params.offset);\n\n  if (params.sort?.length) {\n    params.sort.forEach((s, i) => {\n      q.set(`sort[${i}][field]`, s.field);\n      if (s.direction) q.set(`sort[${i}][direction]`, s.direction);\n    });\n  }\n\n  const qs = q.toString();\n  return qs ? `?${qs}` : \"\";\n}\n","// # Imports\n// imports from core types\nimport type {\n  AirtableFields,\n  AirtableListParams,\n  AirtableListResponse,\n  AirtableRecord,\n  AirtableCreatePayload,\n  AirtableUpdatePayload,\n} from \"../../core/types/airtable\";\n// imports from server client request\nimport { airtableRequest, type AirtableRequestConfig } from \"./request\";\n// imports from server client endpoints\nimport {\n  DEFAULT_AIRTABLE_API_URL,\n  buildBaseUrl,\n  buildListQuery,\n  buildRecordPath,\n  buildTablePath,\n} from \"./endpoints\";\n\n/**\n * @name AirtableClientConfig\n * @kind Type\n * @summary Configuration object for creating an Airtable client with authentication and API settings.\n *\n * @description\n * Type definition for configuration options required to create an Airtable client instance.\n * Contains authentication token, base ID, and optional API URL and timeout settings.\n * Used by createAirtableClient to initialize a client with proper credentials and behavior.\n * All HTTP requests made by the client will use these settings.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Valid Airtable API token with appropriate base access\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - makes HTTP requests to Airtable API\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - type definition only\n * @latency Not applicable\n * @memory Not applicable\n * @rateLimit Not applicable\n * @notes Not applicable\n *\n * @security\n * @inputSanitization Token and baseId are used directly in HTTP requests\n * @secretsHandling Token should be kept secret and never logged. Stored in config object.\n * @pii Not applicable\n *\n * @compatibility\n * @supported Node.js 18+, modern browsers with fetch API\n * @notSupported Node.js < 18 without fetch polyfill\n *\n * @param {string} token - Airtable API personal access token or OAuth token. Required for authentication.\n * @param {string} baseId - Airtable base identifier. Required to target the correct base.\n * @param {string} [apiUrl] - Base URL for Airtable API. Defaults to \"https://api.airtable.com/v0\" if omitted.\n * @param {number} [timeoutMs] - Request timeout in milliseconds. Defaults to 15000ms (15 seconds) if omitted.\n *\n * @returns {Object} Object with required token and baseId, and optional apiUrl and timeoutMs properties.\n *\n * @example\n * // Basic usage\n * const config: AirtableClientConfig = {\n *   token: \"pat123...\",\n *   baseId: \"app123...\"\n * };\n *\n * @example\n * // Advanced usage with custom settings\n * const config: AirtableClientConfig = {\n *   token: process.env.AIRTABLE_TOKEN!,\n *   baseId: process.env.AIRTABLE_BASE_ID!,\n *   apiUrl: \"https://api.airtable.com/v0\",\n *   timeoutMs: 30000\n * };\n *\n * @remarks\n * The token must have appropriate permissions for the base. Keep tokens secure and never commit them to version control.\n *\n * @see createAirtableClient\n */\nexport type AirtableClientConfig = {\n  token: string;\n  baseId: string;\n  /**\n   * Defaults to https://api.airtable.com/v0\n   */\n  apiUrl?: string;\n  /**\n   * Defaults to 15000ms\n   */\n  timeoutMs?: number;\n};\n\n/**\n * @name AirtableClient\n * @kind Type\n * @summary Interface type defining methods for interacting with Airtable REST API (list, get, create, update, delete records).\n *\n * @description\n * Type definition representing an Airtable client instance with methods for CRUD operations.\n * Provides type-safe methods for listing, retrieving, creating, updating, and deleting records.\n * Includes listRecords and listPage methods (listPage is an alias for listRecords for semantic clarity).\n * All methods are generic over TFields to allow consumers to specify field shapes.\n * Returned by createAirtableClient after initialization with valid configuration.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Valid Airtable API token with appropriate base and table access\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - makes HTTP requests to Airtable API\n *\n * @dependencies\n * @requires ./request airtableRequest function for HTTP requests\n * @requires ./endpoints URL building utilities\n * @requires ../../core/types/airtable AirtableCreatePayload and AirtableUpdatePayload types for request bodies\n *\n * @performance\n * @complexity O(1) - type definition only\n * @latency Network-bound: depends on Airtable API response times (typically 100-500ms)\n * @memory Not applicable\n * @rateLimit Subject to Airtable API rate limits (typically 5 requests per second per base)\n * @notes All operations are network-bound. Consider batching and caching strategies for high-volume usage.\n *\n * @security\n * @inputSanitization Table names and record IDs are URL-encoded. Field values are JSON-stringified.\n * @secretsHandling Token is included in Authorization header, never logged\n * @pii May handle PII depending on table field contents\n *\n * @compatibility\n * @supported Node.js 18+, modern browsers with fetch API\n * @notSupported Node.js < 18 without fetch polyfill\n *\n * @returns {Object} Object with methods: listRecords, listPage, getRecord, createRecord, updateRecord, deleteRecord.\n *\n * @example\n * // Basic usage\n * const client = createAirtableClient({ token: \"pat...\", baseId: \"app...\" });\n * const records = await client.listRecords(\"Tasks\");\n *\n * @example\n * // Using listPage alias (same as listRecords)\n * const page = await client.listPage(\"Tasks\", { pageSize: 50 });\n *\n * @example\n * // Advanced usage with typed fields\n * type TaskFields = { Title: string; Status: string };\n * const record = await client.getRecord<TaskFields>(\"Tasks\", \"rec123\");\n *\n * @remarks\n * All methods return Promises and should be awaited. Methods are generic over TFields for type safety.\n * listPage is an alias for listRecords, provided for semantic clarity when fetching paginated results.\n * createRecord and updateRecord use AirtableCreatePayload and AirtableUpdatePayload types respectively.\n *\n * @see createAirtableClient\n * @see AirtableClientConfig\n */\nexport type AirtableClient = {\n  listRecords: <TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    params?: AirtableListParams,\n  ) => Promise<AirtableListResponse<TFields>>;\n\n  listPage: <TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    params?: AirtableListParams,\n  ) => Promise<AirtableListResponse<TFields>>;\n\n  getRecord: <TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    recordId: string,\n  ) => Promise<AirtableRecord<TFields>>;\n\n  createRecord: <TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    fields: Partial<TFields>,\n  ) => Promise<AirtableRecord<TFields>>;\n\n  updateRecord: <TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    recordId: string,\n    fields: Partial<TFields>,\n  ) => Promise<AirtableRecord<TFields>>;\n\n  deleteRecord: (\n    tableName: string,\n    recordId: string,\n  ) => Promise<{ id: string; deleted: boolean }>;\n};\n\n/**\n * @name createAirtableClient\n * @kind Function\n * @summary Creates and returns an Airtable client instance configured with provided settings for API interactions.\n *\n * @description\n * Factory function that creates an AirtableClient instance with methods for interacting with Airtable REST API.\n * Validates required configuration (token and baseId), sets defaults for optional settings (apiUrl, timeoutMs),\n * and initializes internal request configuration. Returns an object with CRUD methods for records.\n * All methods use the configured token and base ID for authentication and routing.\n * Creates listRecords and listPage methods (listPage is an alias for listRecords).\n * Uses AirtableCreatePayload and AirtableUpdatePayload types for request body validation.\n *\n * @category API\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Valid Airtable API token with appropriate base access\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - client makes HTTP requests to Airtable API\n *\n * @dependencies\n * @requires ./request airtableRequest function for HTTP requests\n * @requires ./endpoints URL building utilities (buildBaseUrl, buildTablePath, buildRecordPath, buildListQuery)\n * @requires ../../core/types/airtable AirtableCreatePayload and AirtableUpdatePayload types for request bodies\n *\n * @performance\n * @complexity O(1) - lightweight factory function, no heavy computation\n * @latency Not applicable - synchronous function\n * @memory O(1) - creates client object with method closures\n * @rateLimit Not applicable\n * @notes Function execution is lightweight. Network operations happen when client methods are called.\n *\n * @security\n * @inputSanitization Validates token and baseId are provided (throws if missing). Values used directly in requests.\n * @secretsHandling Token stored in closure, never logged. Passed to airtableRequest in Authorization header.\n * @pii Not applicable\n *\n * @compatibility\n * @supported Node.js 18+, modern browsers with fetch API\n * @notSupported Node.js < 18 without fetch polyfill\n *\n * @param {AirtableClientConfig} config - Configuration object with token, baseId, and optional apiUrl and timeoutMs.\n *\n * @returns {AirtableClient} Client instance with methods: listRecords, listPage, getRecord, createRecord, updateRecord, deleteRecord.\n *\n * @throws {Error} When token is missing or empty - message: \"createAirtableClient: `token` is required\"\n * @throws {Error} When baseId is missing or empty - message: \"createAirtableClient: `baseId` is required\"\n *\n * @example\n * // Basic usage\n * const client = createAirtableClient({\n *   token: \"pat123...\",\n *   baseId: \"app456...\"\n * });\n * const records = await client.listRecords(\"Tasks\");\n *\n * @example\n * // Using listPage alias\n * const page = await client.listPage(\"Tasks\", { pageSize: 50, offset: \"itr123\" });\n *\n * @example\n * // Advanced usage with custom settings\n * const client = createAirtableClient({\n *   token: process.env.AIRTABLE_TOKEN!,\n *   baseId: process.env.AIRTABLE_BASE_ID!,\n *   apiUrl: \"https://api.airtable.com/v0\",\n *   timeoutMs: 30000\n * });\n * const record = await client.getRecord(\"Users\", \"rec789\");\n *\n * @remarks\n * The client instance maintains configuration in closures. Token and baseId are validated at creation time.\n * All client methods are async and return Promises. Network errors are thrown as AirtableHttpError.\n * listPage is an alias for listRecords, provided for semantic clarity when working with pagination.\n * createRecord and updateRecord use type assertions with AirtableCreatePayload and AirtableUpdatePayload respectively.\n *\n * @see AirtableClientConfig\n * @see AirtableClient\n */\nexport function createAirtableClient(\n  config: AirtableClientConfig,\n): AirtableClient {\n  const apiUrl = config.apiUrl ?? DEFAULT_AIRTABLE_API_URL;\n  const timeoutMs = config.timeoutMs ?? 15000;\n\n  if (!config.token)\n    throw new Error(\"createAirtableClient: `token` is required\");\n  if (!config.baseId)\n    throw new Error(\"createAirtableClient: `baseId` is required\");\n\n  const baseUrl = buildBaseUrl(apiUrl, config.baseId);\n\n  const reqConfig: AirtableRequestConfig = {\n    token: config.token,\n    timeoutMs,\n  };\n\n  async function listRecords<TFields extends AirtableFields = AirtableFields>(\n    tableName: string,\n    params?: AirtableListParams,\n  ): Promise<AirtableListResponse<TFields>> {\n    const url = `${baseUrl}${buildTablePath(tableName)}${buildListQuery(params)}`;\n    return airtableRequest<AirtableListResponse<TFields>>({\n      url,\n      method: \"GET\",\n      config: reqConfig,\n    });\n  }\n\n  return {\n    listRecords,\n    listPage: listRecords,\n\n    async getRecord<TFields extends AirtableFields = AirtableFields>(\n      tableName: string,\n      recordId: string,\n    ): Promise<AirtableRecord<TFields>> {\n      const url = `${baseUrl}${buildRecordPath(tableName, recordId)}`;\n      return airtableRequest<AirtableRecord<TFields>>({\n        url,\n        method: \"GET\",\n        config: reqConfig,\n      });\n    },\n\n    async createRecord<TFields extends AirtableFields = AirtableFields>(\n      tableName: string,\n      fields: Partial<TFields>,\n    ): Promise<AirtableRecord<TFields>> {\n      const url = `${baseUrl}${buildTablePath(tableName)}`;\n      return airtableRequest<AirtableRecord<TFields>>({\n        url,\n        method: \"POST\",\n        config: reqConfig,\n        body: { fields } as AirtableCreatePayload<TFields>,\n      });\n    },\n\n    async updateRecord<TFields extends AirtableFields = AirtableFields>(\n      tableName: string,\n      recordId: string,\n      fields: Partial<TFields>,\n    ): Promise<AirtableRecord<TFields>> {\n      const url = `${baseUrl}${buildRecordPath(tableName, recordId)}`;\n      return airtableRequest<AirtableRecord<TFields>>({\n        url,\n        method: \"PATCH\",\n        config: reqConfig,\n        body: { fields } as AirtableUpdatePayload<TFields>,\n      });\n    },\n\n    async deleteRecord(\n      tableName: string,\n      recordId: string,\n    ): Promise<{ id: string; deleted: boolean }> {\n      const url = `${baseUrl}${buildRecordPath(tableName, recordId)}`;\n      return airtableRequest<{ id: string; deleted: boolean }>({\n        url,\n        method: \"DELETE\",\n        config: reqConfig,\n      });\n    },\n  };\n}","import type {\n  AirtableFields,\n  AirtableListParams,\n  AirtableListResponse,\n  AirtableRecord,\n} from \"../../core/types/airtable\";\nimport type { AirtableClient } from \"./createClient\";\n\n/**\n * @name AirtableListAllOptions\n * @kind Type\n * @summary Configuration options for auto-pagination when fetching all records from a table.\n *\n * @description\n * Type definition for options controlling the behavior of listAllRecords function.\n * Provides safety limits to prevent accidental retrieval of extremely large datasets.\n * Used to configure maximum record limits and prevent infinite loops or memory issues.\n * All fields are optional with sensible defaults.\n *\n * @category Data\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Not specified\n * @requiresPermissions Not specified\n * @requiresEnv Not specified\n * @requiresNetwork Not specified\n *\n * @dependencies\n *\n * @performance\n * @complexity O(1) - type definition only\n * @latency Not applicable\n * @memory Not applicable\n * @rateLimit Not applicable\n * @notes Not applicable\n *\n * @security\n * @inputSanitization Not specified\n * @secretsHandling Not applicable\n * @pii Not applicable\n *\n * @compatibility\n * @supported All TypeScript/JavaScript environments\n * @notSupported None\n *\n * @param {number} [maxTotalRecords] - Maximum total records to fetch across all pages. Defaults to 10000 if omitted. Prevents accidental huge pulls.\n *\n * @returns {Object} Object with optional maxTotalRecords property.\n *\n * @example\n * // Basic usage with default limit\n * const options: AirtableListAllOptions = {};\n *\n * @example\n * // Advanced usage with custom limit\n * const options: AirtableListAllOptions = {\n *   maxTotalRecords: 5000\n * };\n *\n * @remarks\n * The maxTotalRecords limit is a safety mechanism. If exceeded, listAllRecords throws an error suggesting to add filters.\n *\n * @see listAllRecords\n */\nexport type AirtableListAllOptions = {\n  /**\n   * Safety cap to prevent accidental infinite loops / huge pulls.\n   * Defaults to 10_000.\n   */\n  maxTotalRecords?: number;\n};\n\n/**\n * @name listAllRecords\n * @kind AsyncFunction\n * @summary Fetches all records from an Airtable table by automatically following pagination offsets until all records are retrieved.\n *\n * @description\n * Async function that retrieves all records from a table by automatically paginating through Airtable API responses.\n * Makes repeated calls to client.listRecords, following the offset token from each response until no more pages remain.\n * Accumulates all records into a single array and returns them. Includes safety limit to prevent accidental huge pulls.\n * Respects filterByFormula and view parameters to reduce payload size. Generic over TFields for type safety.\n * Throws error if maxTotalRecords limit is exceeded, suggesting to add filters.\n *\n * @category Data\n * @since Not specified\n *\n * @requirements\n * @requiresRuntime Node.js >= 18 (for fetch API) or browser with fetch support\n * @requiresPermissions Valid Airtable API token with appropriate table access\n * @requiresEnv Not specified\n * @requiresNetwork Internet required - makes multiple HTTP requests to Airtable API\n *\n * @dependencies\n * @requires ./createClient AirtableClient type and instance\n * @requires ../../core/types/airtable AirtableFields, AirtableListParams, AirtableListResponse, AirtableRecord types\n *\n * @performance\n * @complexity O(n/p) where n is total records and p is page size - makes n/p API calls\n * @latency Network-bound: depends on number of pages and API response times (typically 100-500ms per page)\n * @memory O(n) - accumulates all records in memory array\n * @rateLimit Subject to Airtable API rate limits (typically 5 requests per second per base). Multiple pages = multiple requests.\n * @notes For large tables, consider using filters to reduce payload. Each page requires a separate API call.\n *\n * @security\n * @inputSanitization tableName and params passed through to client.listRecords which handles encoding\n * @secretsHandling Token handled by client, never logged\n * @pii May return PII depending on table field contents\n *\n * @compatibility\n * @supported Node.js 18+, modern browsers with fetch API\n * @notSupported Node.js < 18 without fetch polyfill\n *\n * @param {Object} args - Arguments object containing client, tableName, params, and options.\n * @param {AirtableClient} args.client - Airtable client instance for making API requests.\n * @param {string} args.tableName - Name of the Airtable table to fetch records from.\n * @param {Omit<AirtableListParams, \"offset\">} [args.params] - Query parameters (offset is excluded as it's managed internally). Use filterByFormula or view to reduce payload.\n * @param {AirtableListAllOptions} [args.options] - Options for controlling pagination behavior. Defaults to maxTotalRecords: 10000.\n *\n * @returns {Promise<Array<AirtableRecord<TFields>>>} Promise resolving to array of all records from the table.\n *\n * @throws {Error} When maxTotalRecords limit is exceeded - message includes limit value and suggests adding filters\n *\n * @example\n * // Basic usage\n * const allRecords = await listAllRecords({\n *   client,\n *   tableName: \"Tasks\"\n * });\n *\n * @example\n * // Advanced usage with filters and custom limit\n * const openTasks = await listAllRecords({\n *   client,\n *   tableName: \"Tasks\",\n *   params: {\n *     filterByFormula: \"{Status}='Open'\",\n *     sort: [{ field: \"Created\", direction: \"desc\" }]\n *   },\n *   options: { maxTotalRecords: 5000 }\n * });\n *\n * @remarks\n * Airtable may enforce its own max limits depending on plan. Use filterByFormula and view to reduce payload.\n * This function makes multiple API calls (one per page), so be mindful of rate limits for large tables.\n *\n * @see AirtableClient\n * @see AirtableListAllOptions\n * @see AirtableListParams\n */\nexport async function listAllRecords<\n  TFields extends AirtableFields = AirtableFields,\n>(args: {\n  client: AirtableClient;\n  tableName: string;\n  params?: Omit<AirtableListParams, \"offset\">;\n  options?: AirtableListAllOptions;\n}): Promise<Array<AirtableRecord<TFields>>> {\n  const { client, tableName, params, options } = args;\n\n  const maxTotalRecords = options?.maxTotalRecords ?? 10_000;\n\n  const out: Array<AirtableRecord<TFields>> = [];\n  let offset: string | undefined = undefined;\n\n  while (true) {\n    const page: AirtableListResponse<TFields> = await client.listRecords<TFields>(tableName, {\n      ...(params ?? {}),\n      offset,\n    });\n\n    out.push(...page.records);\n\n    if (out.length > maxTotalRecords) {\n      throw new Error(\n        `listAllRecords: exceeded maxTotalRecords (${maxTotalRecords}). ` +\n          `Add filters or increase the limit explicitly.`,\n      );\n    }\n\n    if (!page.offset) break;\n    offset = page.offset;\n  }\n\n  return out;\n}\n","import type {\n  AirtableFields,\n  AirtableListParams,\n  AirtableRecord,\n} from \"../../core/types/airtable\";\nimport type { AirtableClient } from \"../client/createClient\";\nimport { listAllRecords, type AirtableListAllOptions } from \"../client/pagination\";\n\nexport type TableMapper<TFields extends AirtableFields, TModel> = {\n  /**\n   * Convert a domain model into Airtable fields (for create/update).\n   * Keep this pure (no network).\n   */\n  toFields: (model: Partial<TModel>) => Partial<TFields>;\n\n  /**\n   * Convert an Airtable record into a domain model.\n   * Should validate / normalize where appropriate.\n   */\n  fromRecord: (record: AirtableRecord<TFields>) => TModel;\n};\n\nexport type TableRepo<TFields extends AirtableFields, TModel> = {\n  listPage: (params?: AirtableListParams) => Promise<{ records: TModel[]; offset?: string }>;\n  listAll: (params?: Omit<AirtableListParams, \"offset\">, options?: AirtableListAllOptions) => Promise<TModel[]>;\n  get: (recordId: string) => Promise<TModel>;\n  create: (model: Partial<TModel>) => Promise<TModel>;\n  update: (recordId: string, patch: Partial<TModel>) => Promise<TModel>;\n  delete: (recordId: string) => Promise<{ id: string; deleted: boolean }>;\n};\n\nexport function createTableRepo<TFields extends AirtableFields, TModel>(args: {\n  client: AirtableClient;\n  tableName: string;\n  mapper: TableMapper<TFields, TModel>;\n}): TableRepo<TFields, TModel> {\n  const { client, tableName, mapper } = args;\n\n  return {\n    async listPage(params?: AirtableListParams) {\n      const page = await client.listRecords<TFields>(tableName, params);\n      return {\n        records: page.records.map(mapper.fromRecord),\n        offset: page.offset,\n      };\n    },\n\n    async listAll(params?: Omit<AirtableListParams, \"offset\">, options?: AirtableListAllOptions) {\n      const records = await listAllRecords<TFields>({\n        client,\n        tableName,\n        params,\n        options,\n      });\n      return records.map(mapper.fromRecord);\n    },\n\n    async get(recordId: string) {\n      const record = await client.getRecord<TFields>(tableName, recordId);\n      return mapper.fromRecord(record);\n    },\n\n    async create(model: Partial<TModel>) {\n      const fields = mapper.toFields(model);\n      const record = await client.createRecord<TFields>(tableName, fields);\n      return mapper.fromRecord(record);\n    },\n\n    async update(recordId: string, patch: Partial<TModel>) {\n      const fields = mapper.toFields(patch);\n      const record = await client.updateRecord<TFields>(tableName, recordId, fields);\n      return mapper.fromRecord(record);\n    },\n\n    async delete(recordId: string) {\n      return client.deleteRecord(tableName, recordId);\n    },\n  };\n}\n","import type { AirtableClient } from \"../client/createClient\";\nimport { createTableRepo } from \"./createTableRepo\";\nimport type { Lead } from \"../../core/domain/lead\";\nimport { leadFromRecord, leadToFields, type LeadFields } from \"../../core/mappers/leadMapper\";\n\nexport function createLeadsRepo(args: {\n  client: AirtableClient;\n  tableName?: string;\n}) {\n  return createTableRepo<LeadFields, Lead>({\n    client: args.client,\n    tableName: args.tableName ?? \"Leads\",\n    mapper: {\n      toFields: leadToFields,\n      fromRecord: leadFromRecord,\n    },\n  });\n}\n"],"mappings":"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","names":[]}